{% extends "base.html" %}

{% block title %}{{ hypervisor.agent_id }} · Hypervisor · PlayrServers Management{% endblock %}

{% block head_extra %}
  {{ super() }}
  <link rel="stylesheet" href="{{ request.url_for('static', path='css/xterm.css') }}" />
{% endblock %}

{% block content %}
<div id="hypervisor-detail" data-agent="{{ hypervisor.agent_id }}">
  <header class="page-head">
    <div class="page-head__content">
      <h1 class="page-head__title">{{ hypervisor.agent_id }}</h1>
      <p class="page-head__subtitle">Orchestrate {{ hypervisor.hostname }} and the virtual machines provisioned on this hypervisor.</p>
      <div class="badge-group">
        <span class="status-pill{% if hypervisor.is_online %} status-pill--success{% else %} status-pill--muted{% endif %}">{{ 'Online' if hypervisor.is_online else 'Offline' }}</span>
        <span class="badge badge--accent">Endpoint {{ hypervisor.endpoint_host }}:{{ hypervisor.endpoint_port }}</span>
        {% for capability in hypervisor.capabilities %}
        <span class="badge">{{ capability }}</span>
        {% endfor %}
      </div>
    </div>
    <div class="page-head__actions">
      <a class="button button--primary" href="{{ request.url_for('ui_dashboard') }}">Back to dashboard</a>
    </div>
  </header>

  <section class="card">
    <h2 class="card__title">Host overview</h2>
    <p class="card__subtitle">System information reported by the connected agent.</p>
    <dl class="detail-grid">
      {% for label, value in host_overview %}
      <div class="detail-grid__item">
        <dt>{{ label }}</dt>
        <dd>{{ value }}</dd>
      </div>
      {% endfor %}
    </dl>
  </section>

  <section class="card">
    <h2 class="card__title">Performance metrics</h2>
    <p class="card__subtitle">Live CPU utilisation for each physical core.</p>
    {% if cpu_metrics %}
    <ul class="metric-list">
      {% for core in cpu_metrics %}
      <li class="metric-list__item">
        <span class="metric-list__label">{{ core.label }}</span>
        <div class="metric-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="{{ '%.1f'|format(core.usage) }}">
          <div class="metric-bar__fill" style="width: {{ '%.2f'|format(core.usage) }}%;"></div>
        </div>
        <span class="metric-list__value{% if core.usage >= 85 %} metric-list__value--high{% elif core.usage <= 20 %} metric-list__value--healthy{% endif %}">{{ '%.1f'|format(core.usage) }}%</span>
      </li>
      {% endfor %}
    </ul>
    {% else %}
    <p class="text-muted">No per-core metrics have been reported yet. Ensure the agent is publishing performance data.</p>
    {% endif %}
  </section>

  <section class="card">
    <h2 class="card__title">Virtual machines</h2>
    <p class="card__subtitle">Review guests hosted on this hypervisor and queue management actions.</p>
    {% if virtual_machines %}
    <div class="table" data-vm-table data-agent="{{ hypervisor.agent_id }}">
      <div class="table__header">
        <span>Name</span>
        <span>Status</span>
        <span>Power</span>
        <span>CPU</span>
        <span>Memory</span>
        <span>Actions</span>
      </div>
      {% for vm in virtual_machines %}
      <div class="table__row" data-vm-id="{{ vm.id }}">
        <span class="table__cell table__cell--emphasis">{{ vm.name }}</span>
        <span class="table__cell">{{ vm.status or 'Unknown' }}</span>
        <span class="table__cell">{{ vm.power_state or 'Unknown' }}</span>
        <span class="table__cell">{{ vm.cpu or '—' }}</span>
        <span class="table__cell">{{ vm.memory or '—' }}</span>
        <span class="table__cell">
          <div class="vm-actions">
            <button type="button" class="button" data-action="start">Start</button>
            <button type="button" class="button" data-action="stop">Stop</button>
            <button type="button" class="button" data-action="restart">Restart</button>
            <button type="button" class="button" data-action="force-stop">Force stop</button>
            <button type="button" class="button" data-action="console">Virtual console</button>
          </div>
        </span>
      </div>
      {% endfor %}
    </div>
    <p class="text-muted" data-vm-status>Queued actions will be delivered through the secure management tunnel.</p>
    {% else %}
    <div class="empty-state">
      <h2>No virtual machines reported</h2>
      <p>The agent has not published an inventory yet. It will appear here once available.</p>
    </div>
    {% endif %}
  </section>

  <section class="card">
    <h2 class="card__title">SSH terminal</h2>
    <p class="card__subtitle">Request an ephemeral tunnel through the management plane to open a secure shell without exposing additional ports.</p>
    <div class="ssh-terminal" data-agent="{{ hypervisor.agent_id }}">
      <div class="ssh-terminal__actions">
        <button type="button" class="button" data-ssh-launch>Launch terminal</button>
      </div>
      <div class="ssh-terminal__console" data-ssh-console hidden></div>
      <div class="ssh-terminal__status" data-ssh-status>Click “Launch terminal” to open a root session.</div>
    </div>
  </section>
</div>

<script src="{{ request.url_for('static', path='js/xterm.js') }}"></script>
<script src="{{ request.url_for('static', path='js/xterm-addon-fit.js') }}"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('hypervisor-detail');
    if (!container) {
      return;
    }
    const agentId = container.dataset.agent;

    const vmTable = container.querySelector('[data-vm-table]');
    const vmStatus = container.querySelector('[data-vm-status]');
    if (vmTable) {
      vmTable.addEventListener('click', async (event) => {
        const button = event.target.closest('button[data-action]');
        if (!button) {
          return;
        }
        const row = button.closest('[data-vm-id]');
        if (!row) {
          return;
        }
        const vmId = row.dataset.vmId;
        const action = button.dataset.action;
        const originalLabel = button.textContent;
        button.disabled = true;
        button.textContent = 'Processing…';
        try {
          const response = await fetch(`/hypervisors/${encodeURIComponent(agentId)}/vms/${encodeURIComponent(vmId)}/${encodeURIComponent(action)}`, {
            method: 'POST',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json',
              'X-Requested-With': 'fetch'
            },
            body: JSON.stringify({})
          });
          const payload = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(payload.detail || 'Unable to queue action.');
          }
          if (vmStatus) {
            vmStatus.textContent = payload.message || `Queued ${payload.action || action} for ${payload.vm || vmId}.`;
          }
        } catch (error) {
          if (vmStatus) {
            vmStatus.textContent = error.message || 'Action failed. Check the hypervisor connection.';
          }
        } finally {
          button.disabled = false;
          button.textContent = originalLabel;
        }
      });
    }

    const sshPanel = container.querySelector('.ssh-terminal');
    if (!sshPanel) {
      return;
    }
    const launchButton = sshPanel.querySelector('[data-ssh-launch]');
    const status = sshPanel.querySelector('[data-ssh-status]');
    const consoleElement = sshPanel.querySelector('[data-ssh-console]');
    let terminalSocket = null;
    let terminalInstance = null;
    let fitAddon = null;
    let resizeHandler = null;
    let consoleClickHandler = null;
    let consoleFocusHandler = null;
    const textDecoder = window.TextDecoder ? new TextDecoder() : null;

    const closeTerminal = () => {
      if (terminalSocket) {
        try {
          terminalSocket.close();
        } catch (socketError) {
          console.warn('Unable to close terminal socket', socketError);
        }
      }
      terminalSocket = null;
      if (resizeHandler) {
        window.removeEventListener('resize', resizeHandler);
        resizeHandler = null;
      }
      if (fitAddon && typeof fitAddon.dispose === 'function') {
        try {
          fitAddon.dispose();
        } catch (addonError) {
          console.warn('Failed to dispose terminal fit addon', addonError);
        }
      }
      fitAddon = null;
      if (terminalInstance && typeof terminalInstance.dispose === 'function') {
        terminalInstance.dispose();
      }
      terminalInstance = null;
      if (consoleElement) {
        if (consoleClickHandler) {
          consoleElement.removeEventListener('mousedown', consoleClickHandler);
          consoleClickHandler = null;
        }
        if (consoleFocusHandler) {
          consoleElement.removeEventListener('focus', consoleFocusHandler);
          consoleFocusHandler = null;
        }
        consoleElement.removeAttribute('tabindex');
        consoleElement.innerHTML = '';
        consoleElement.setAttribute('hidden', 'hidden');
      }
    };

    const buildWebSocketUrl = (payload) => {
      if (!payload) {
        return null;
      }
      if (payload.websocket_url) {
        return payload.websocket_url;
      }
      if (!payload.websocket_path) {
        return null;
      }
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      return `${protocol}//${window.location.host}${payload.websocket_path}`;
    };

    const initialiseTerminal = (payload) => {
      if (!window.Terminal || !consoleElement) {
        if (status) {
          status.textContent = 'Terminal support is unavailable in this browser.';
        }
        return;
      }

      closeTerminal();
      consoleElement.removeAttribute('hidden');

      terminalInstance = new window.Terminal({
        convertEol: true,
        cursorBlink: true,
        fontFamily: '"JetBrains Mono", "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
        fontSize: 14,
        theme: {
          background: '#0f172a',
          foreground: '#e2e8f0',
          cursor: '#38bdf8',
        },
      });

      if (window.FitAddon && typeof window.FitAddon.FitAddon === 'function') {
        fitAddon = new window.FitAddon.FitAddon();
        terminalInstance.loadAddon(fitAddon);
      } else {
        fitAddon = null;
      }

      terminalInstance.open(consoleElement);

      const focusTerminal = () => {
        if (terminalInstance) {
          terminalInstance.focus();
        }
      };

      consoleElement.setAttribute('tabindex', '0');
      consoleFocusHandler = focusTerminal;
      consoleElement.addEventListener('focus', consoleFocusHandler);
      consoleClickHandler = (event) => {
        event.preventDefault();
        focusTerminal();
      };
      consoleElement.addEventListener('mousedown', consoleClickHandler);

      if (fitAddon && typeof fitAddon.fit === 'function') {
        resizeHandler = () => {
          try {
            fitAddon.fit();
          } catch (fitError) {
            console.debug('Terminal resize failed', fitError);
          }
        };
        resizeHandler();
        window.addEventListener('resize', resizeHandler);
      }

      focusTerminal();

      const wsTarget = buildWebSocketUrl(payload);
      if (!wsTarget) {
        if (status) {
          status.textContent = 'Terminal endpoint missing from tunnel response.';
        }
        return;
      }

      try {
        terminalSocket = new WebSocket(wsTarget);
      } catch (socketError) {
        if (status) {
          status.textContent = 'Failed to open terminal connection.';
        }
        console.error('Unable to create terminal socket', socketError);
        return;
      }

      terminalSocket.binaryType = 'arraybuffer';

      terminalSocket.addEventListener('open', () => {
        if (status) {
          status.textContent = 'Terminal connected. Root session ready.';
        }
        if (launchButton) {
          launchButton.textContent = 'Reconnect terminal';
        }
        if (terminalInstance) {
          terminalInstance.focus();
        }
      });

      terminalSocket.addEventListener('message', (event) => {
        if (!terminalInstance) {
          return;
        }
        if (event.data instanceof ArrayBuffer) {
          const view = new Uint8Array(event.data);
          if (textDecoder) {
            terminalInstance.write(textDecoder.decode(view));
          } else {
            let text = '';
            for (let i = 0; i < view.length; i += 1) {
              text += String.fromCharCode(view[i]);
            }
            terminalInstance.write(text);
          }
          return;
        }
        if (typeof event.data === 'string') {
          terminalInstance.write(event.data);
        }
      });

      const handleSocketClose = (event) => {
        if (resizeHandler) {
          window.removeEventListener('resize', resizeHandler);
          resizeHandler = null;
        }
        terminalSocket = null;
        if (terminalInstance) {
          terminalInstance.write(`\r\nSession closed (code ${event.code}).\r\n`);
        }
        if (status) {
          if (event.wasClean) {
            status.textContent = 'Terminal session ended.';
          } else {
            status.textContent = 'Terminal disconnected. Launch again to reconnect.';
          }
        }
      };

      terminalSocket.addEventListener('close', handleSocketClose);
      terminalSocket.addEventListener('error', () => {
        if (status) {
          status.textContent = 'Terminal encountered a connection issue.';
        }
      });

      terminalInstance.onData((data) => {
        if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
          terminalSocket.send(data);
        }
      });
    };

    if (launchButton) {
      launchButton.addEventListener('click', async () => {
        launchButton.disabled = true;
        if (status) {
          status.textContent = 'Requesting tunnel…';
        }
        try {
          const response = await fetch(`/hypervisors/${encodeURIComponent(agentId)}/terminal`, {
            method: 'POST',
            headers: {
              'Accept': 'application/json',
              'X-Requested-With': 'fetch'
            }
          });
          const payload = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(payload.detail || 'Unable to create tunnel.');
          }
          if (status) {
            status.textContent = payload.message || `Tunnel ${payload.tunnel_id} established on port ${payload.remote_port}.`;
          }
          initialiseTerminal(payload);
        } catch (error) {
          if (status) {
            status.textContent = error && error.message ? error.message : 'Unable to request tunnel. Ensure the hypervisor is online.';
          }
        } finally {
          launchButton.disabled = false;
        }
      });
    }

    window.addEventListener('beforeunload', closeTerminal);
  });
</script>
{% endblock %}
