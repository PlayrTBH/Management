{% extends "layout.html" %}
{% block extra_head %}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
{% endblock %}
{% block title %}Management · PlayrServers Control Plane{% endblock %}
{% block content %}
<div class="stack">
    <div class="card">
        <h1>Hypervisor fleet management</h1>
        <p class="muted">Register remote virtualization hosts, audit their metadata, and keep SSH credentials synchronized with the automation API.</p>
        {% if messages %}
            {% for item in messages %}
                {% set category = item.category if item.category is defined else 'info' %}
                <div class="notice{% if category == 'error' %} danger{% elif category == 'success' %} success{% endif %}">{{ item.message }}</div>
            {% endfor %}
        {% endif %}
        <div class="management-grid">
            <section>
                <h2>Registered hypervisors</h2>
                <div class="agent-list" id="agent-list">
                    {% if agents %}
                        {% for agent in agents %}
                            <div class="agent-entry" data-agent-id="{{ agent.id }}">
                                <button type="button" class="agent-tile{% if selected_agent and agent.id == selected_agent.id %} active{% endif %}" data-agent='{{ agent | tojson }}'>
                                    <strong>{{ agent.name }}</strong>
                                    <div class="agent-meta">
                                        <span>{{ agent.hostname }}:{{ agent.port }}</span>
                                        <span>SSH · {{ agent.username }}</span>
                                    </div>
                                </button>
                                <div class="agent-actions">
                                    <span class="muted">Created {{ agent.created_at }}</span>
                                    <form method="post" action="{{ agent.remove_url }}" onsubmit="return confirm('Remove {{ agent.name }}?');">
                                        <button type="submit" class="text-button">Remove</button>
                                    </form>
                                </div>
                            </div>
                        {% endfor %}
                    {% else %}
                        <p class="muted">No hypervisors are paired yet. Install and start the PlayrServers agent on a host to enrol it automatically.</p>
                    {% endif %}
                </div>
            </section>
            <section>
                <h2>Pair hypervisors</h2>
                <div class="notice warning">
                    <p><strong>Agent pairing required.</strong> Manual onboarding with raw SSH credentials has been disabled. Install the PlayrServers agent service on each host to register it with the control plane.</p>
                </div>
                <p>Once the agent connects using your automation API key, the hypervisor appears in this list automatically. Keep the agent running to ensure SSH keys and metadata stay synchronized.</p>
                <ol>
                    <li>Install the <strong>HVDeploy</strong> agent on the target hypervisor.</li>
                    <li>Create <code>/etc/playrservers/agent.env</code> with the API base URL and key from your <a href="{{ request.url_for('account') }}">account page</a>.</li>
                    <li>Start the agent service; it will call <code>POST /v1/servers/connect</code> to enrol the host.</li>
                </ol>
                <p class="help-text">Need the agent toolkit? The operations team maintains download links and deployment guides in the remote agent section below.</p>
            </section>
        </div>
    </div>

    <div class="card">
        <div class="section-header">
            <h2>Virtual machine inventory</h2>
            <span class="badge" id="selected-agent-label">{% if selected_agent %}{{ selected_agent.name }}{% else %}No agent selected{% endif %}</span>
        </div>
        <div id="vm-status" class="muted">
            {% if not agents %}
                Pair a hypervisor with the agent service to view its virtual machines.
            {% elif not selected_agent %}
                Select a hypervisor to load its virtual machines.
            {% else %}
                Loading virtual machines…
            {% endif %}
        </div>
        <div class="table-wrapper" id="vm-table-wrapper"{% if not selected_agent %} style="display: none;"{% endif %}>
            <table id="vm-table">
                <thead>
                    <tr>
                        <th scope="col">Name</th>
                        <th scope="col">State</th>
                        <th scope="col">Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <div class="card">
        <div class="section-header">
            <h2>Deploy a virtual machine</h2>
            <span class="badge" id="deployment-selected-agent">{% if selected_agent %}{{ selected_agent.name }}{% else %}No agent selected{% endif %}</span>
        </div>
        <div id="deployment-placeholder" class="placeholder-box"{% if selected_agent %} style="display: none;"{% endif %}>
            {% if not agents %}
                Pair a hypervisor with the agent service to enable guided VM deployments.
            {% elif not selected_agent %}
                Select a hypervisor to prepare an automated operating system installation.
            {% endif %}
        </div>
        <div id="deployment-section"{% if not selected_agent %} style="display: none;"{% endif %}>
            <form id="deployment-form" class="deployment-form">
                <div class="field">
                    <label for="deployment-profile">Operating system</label>
                    <select id="deployment-profile" name="profile_id"></select>
                    <p class="help-text" id="deployment-description"></p>
                    <p class="help-text">Source: <a id="deployment-source" href="#" target="_blank" rel="noopener">View documentation</a></p>
                </div>
                <div class="deployment-grid">
                    <div class="field">
                        <label for="deployment-name">VM name</label>
                        <input type="text" id="deployment-name" name="vm_name" required placeholder="vm-example">
                    </div>
                    <div class="field">
                        <label for="deployment-memory">Memory (MiB)</label>
                        <input type="number" id="deployment-memory" name="memory_mb" min="512" step="256" required>
                    </div>
                    <div class="field">
                        <label for="deployment-vcpus">vCPUs</label>
                        <input type="number" id="deployment-vcpus" name="vcpus" min="1" step="1" required>
                    </div>
                    <div class="field">
                        <label for="deployment-disk">Disk size (GiB)</label>
                        <input type="number" id="deployment-disk" name="disk_gb" min="10" step="1" required>
                    </div>
                </div>
                <div class="deployment-credentials">
                    <div>
                        <h3>Default credentials</h3>
                        <div class="field">
                            <label for="deployment-username">Username</label>
                            <input type="text" id="deployment-username" name="username" required maxlength="32" autocomplete="username">
                        </div>
                        <div class="field">
                            <label for="deployment-password">Password</label>
                            <input type="text" id="deployment-password" name="password" required minlength="12" maxlength="128" autocomplete="new-password" placeholder="Generate a strong password">
                            <p class="help-text">Passwords must be at least 12 characters and cannot include spaces or colons.</p>
                        </div>
                        <p class="help-text" id="deployment-notes"></p>
                    </div>
                    <div>
                        <h3>Download details</h3>
                        <dl class="credential-list">
                            <div><dt>Download</dt><dd><a id="deployment-download" href="#" target="_blank" rel="noopener">Open image</a></dd></div>
                            <div><dt>OS variant</dt><dd id="deployment-variant">—</dd></div>
                        </dl>
                    </div>
                </div>
                <div class="deployment-actions">
                    <button type="submit" class="button">Start deployment</button>
                    <span id="deployment-status" class="ssh-status">Select an operating system to continue.</span>
                </div>
            </form>
        </div>
    </div>

    <div class="card">
        <div class="section-header">
            <h2>Deployment activity</h2>
            <button type="button" id="deployment-refresh" class="button small secondary">Refresh</button>
        </div>
        <div id="deployment-activity-error" class="notice danger" style="display: none;"></div>
        <div id="deployment-activity-empty" class="placeholder-box">
            No deployments have been started yet. Launch a virtual machine to track its progress here.
        </div>
        <div id="deployment-activity" class="deployment-activity-list" style="display: none;"></div>
    </div>

    <div class="card">
        <div class="section-header">
            <h2>Virtual console</h2>
            <span class="badge" id="vm-console-label">{% if selected_agent %}No VM selected{% else %}Unavailable{% endif %}</span>
        </div>
        <div id="vm-console-placeholder" class="placeholder-box">
            {% if not agents %}
                Pair a hypervisor with the agent service to access guest consoles.
            {% elif not selected_agent %}
                Select a hypervisor and choose a VM to open its console.
            {% else %}
                Select a virtual machine from the inventory to open its console.
            {% endif %}
        </div>
        <div id="vm-console-section"{% if not selected_agent %} style="display: none;"{% endif %}>
            <p class="muted">Interact with the selected guest through <code>virsh console</code>. Press <kbd>Ctrl</kbd> + <kbd>]</kbd> to release the session.</p>
            <div class="ssh-terminal-wrapper">
                <div id="vm-console-terminal" class="ssh-terminal"></div>
                <div id="vm-console-overlay" class="ssh-terminal-overlay">Select a virtual machine to open its console.</div>
            </div>
            <div class="ssh-controls">
                <div class="ssh-buttons">
                    <button type="button" id="vm-console-connect" class="button secondary">Connect</button>
                    <button type="button" id="vm-console-disconnect" class="button secondary" disabled>Disconnect</button>
                </div>
                <span id="vm-console-status" class="ssh-status">Disconnected.</span>
            </div>
            <p class="help-text">Console sessions stream directly from the hypervisor. Use the disconnect button or press <kbd>Ctrl</kbd> + <kbd>]</kbd> to exit.</p>
        </div>
    </div>

    <div class="card">
        <div class="section-header">
            <h2>Host diagnostics</h2>
            <span class="badge" id="host-info-timestamp">{% if selected_agent %}Awaiting data{% else %}Idle{% endif %}</span>
        </div>
        <div id="host-info-placeholder" class="placeholder-box">
            {% if not agents %}
                Pair a hypervisor with the agent service to monitor its performance metrics.
            {% elif not selected_agent %}
                Select a hypervisor to view system metrics.
            {% else %}
                Collecting host diagnostics…
            {% endif %}
        </div>
        <div id="host-info-section" style="display: none;">
            <div id="host-info-message" class="notice" style="display: none;"></div>
            <div class="host-info-grid">
                <div>
                    <h3>System facts</h3>
                    <dl class="stat-list">
                        <div><dt>Hostname</dt><dd id="host-system-hostname">—</dd></div>
                        <div><dt>Kernel</dt><dd id="host-kernel">—</dd></div>
                        <div><dt>SSH user</dt><dd id="host-system-user">—</dd></div>
                        <div><dt>CPU model</dt><dd id="host-cpu-model">—</dd></div>
                        <div><dt>CPU(s)</dt><dd id="host-cpu-count">—</dd></div>
                        <div><dt>CPU frequency</dt><dd id="host-cpu-frequency">—</dd></div>
                        <div><dt>Memory</dt><dd id="host-memory-total">—</dd></div>
                    </dl>
                </div>
                <div>
                    <h3>Performance</h3>
                    <dl class="stat-list">
                        <div><dt>Load avg (1/5/15m)</dt><dd id="host-load">—</dd></div>
                        <div><dt>Memory usage</dt><dd id="host-memory-usage">—</dd></div>
                        <div><dt>Memory available</dt><dd id="host-memory-available">—</dd></div>
                        <div><dt>Collected</dt><dd id="host-info-updated">—</dd></div>
                    </dl>
                </div>
            </div>
        </div>
    </div>

    <div class="card">
        <div class="section-header">
            <h2>Direct SSH console</h2>
            <span class="badge warning">Operator access</span>
        </div>
        <div id="ssh-placeholder" class="placeholder-box"{% if selected_agent %} style="display: none;"{% endif %}>
            Select a hypervisor to populate SSH connection details.
        </div>
        <div id="ssh-section"{% if not selected_agent %} style="display: none;"{% endif %}>
            <p class="muted">Use the in-browser console to connect to the selected hypervisor or copy the ready-to-run SSH command.</p>
            <div class="ssh-terminal-wrapper">
                <div id="ssh-terminal" class="ssh-terminal"></div>
                <div id="ssh-terminal-overlay" class="ssh-terminal-overlay">Select a hypervisor and click Connect to start a session.</div>
            </div>
            <div class="ssh-controls">
                <div class="ssh-buttons">
                    <button type="button" id="ssh-connect" class="button secondary">Connect</button>
                    <button type="button" id="ssh-disconnect" class="button secondary" disabled>Disconnect</button>
                    <button type="button" id="ssh-copy-command" class="button secondary">Copy SSH command</button>
                </div>
                <span id="ssh-terminal-status" class="ssh-status">Disconnected.</span>
            </div>
            <code id="ssh-command"></code>
            <p class="help-text">Sessions authenticate using the stored automation key and run entirely within your browser.</p>
        </div>
    </div>

    <div class="card">
        <h2>Remote agent deployment</h2>
        <div class="placeholder-box">
            <p>Guidance on locating and installing the PlayrServers remote agent will appear here. Include package repository locations, service management commands, and upgrade advice once distribution details are finalized.</p>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
<script id="agent-data" type="application/json">{{ agents | tojson }}</script>
<script id="selected-agent" type="application/json">{{ selected_agent | tojson if selected_agent else 'null' }}</script>
<script id="management-endpoints" type="application/json">{{ endpoints | tojson }}</script>
<script id="deployment-profiles" type="application/json">{{ deployment_profiles | tojson }}</script>
<script>
(() => {
    const agentDataElement = document.getElementById('agent-data');
    const selectedAgentElement = document.getElementById('selected-agent');
    const endpointsElement = document.getElementById('management-endpoints');
    const deploymentProfilesElement = document.getElementById('deployment-profiles');

    if (!agentDataElement || !selectedAgentElement || !endpointsElement || !deploymentProfilesElement) {
        return;
    }

    const state = {
        agents: JSON.parse(agentDataElement.textContent || '[]'),
        selectedAgent: JSON.parse(selectedAgentElement.textContent || 'null'),
        endpoints: JSON.parse(endpointsElement.textContent || '{}'),
        deploymentProfiles: JSON.parse(deploymentProfilesElement.textContent || '[]'),
        vms: [],
        selectedVm: null,
        deployments: [],
        deploymentDetails: {},
    };

    if (!state.endpoints || !state.endpoints.list_vms) {
        return;
    }

    const agentList = document.getElementById('agent-list');
    const vmStatus = document.getElementById('vm-status');
    const vmTableWrapper = document.getElementById('vm-table-wrapper');
    const vmTableBody = document.querySelector('#vm-table tbody');
    const agentLabel = document.getElementById('selected-agent-label');
    const sshCommand = document.getElementById('ssh-command');
    const sshSection = document.getElementById('ssh-section');
    const sshPlaceholder = document.getElementById('ssh-placeholder');
    const sshTerminalContainer = document.getElementById('ssh-terminal');
    const sshTerminalOverlay = document.getElementById('ssh-terminal-overlay');
    const sshConnectButton = document.getElementById('ssh-connect');
    const sshDisconnectButton = document.getElementById('ssh-disconnect');
    const sshCopyButton = document.getElementById('ssh-copy-command');
    const sshStatus = document.getElementById('ssh-terminal-status');
    const hostInfoPlaceholder = document.getElementById('host-info-placeholder');
    const hostInfoSection = document.getElementById('host-info-section');
    const hostInfoMessage = document.getElementById('host-info-message');
    const hostInfoTimestamp = document.getElementById('host-info-timestamp');
    const hostSystemHostname = document.getElementById('host-system-hostname');
    const hostSystemUser = document.getElementById('host-system-user');
    const hostKernel = document.getElementById('host-kernel');
    const hostCpuModel = document.getElementById('host-cpu-model');
    const hostCpuCount = document.getElementById('host-cpu-count');
    const hostCpuFrequency = document.getElementById('host-cpu-frequency');
    const hostMemoryTotal = document.getElementById('host-memory-total');
    const hostMemoryUsage = document.getElementById('host-memory-usage');
    const hostMemoryAvailable = document.getElementById('host-memory-available');
    const hostInfoUpdated = document.getElementById('host-info-updated');
    const hostLoad = document.getElementById('host-load');
    const deploymentActivityContainer = document.getElementById('deployment-activity');
    const deploymentActivityEmpty = document.getElementById('deployment-activity-empty');
    const deploymentActivityError = document.getElementById('deployment-activity-error');
    const deploymentRefreshButton = document.getElementById('deployment-refresh');
    const deploymentPlaceholder = document.getElementById('deployment-placeholder');
    const deploymentSection = document.getElementById('deployment-section');
    const deploymentForm = document.getElementById('deployment-form');
    const deploymentProfileSelect = document.getElementById('deployment-profile');
    const deploymentDescription = document.getElementById('deployment-description');
    const deploymentSourceLink = document.getElementById('deployment-source');
    const deploymentDownloadLink = document.getElementById('deployment-download');
    const deploymentUsername = document.getElementById('deployment-username');
    const deploymentPassword = document.getElementById('deployment-password');
    const deploymentVariant = document.getElementById('deployment-variant');
    const deploymentNotes = document.getElementById('deployment-notes');
    const deploymentStatus = document.getElementById('deployment-status');
    const deploymentNameInput = document.getElementById('deployment-name');
    const deploymentMemoryInput = document.getElementById('deployment-memory');
    const deploymentVcpusInput = document.getElementById('deployment-vcpus');
    const deploymentDiskInput = document.getElementById('deployment-disk');
    const deploymentAgentBadge = document.getElementById('deployment-selected-agent');
    const deploymentUsernameDefaultPlaceholder = deploymentUsername ? deploymentUsername.getAttribute('placeholder') || '' : '';
    const deploymentPasswordDefaultPlaceholder = deploymentPassword ? deploymentPassword.getAttribute('placeholder') || '' : '';
    const vmConsoleLabel = document.getElementById('vm-console-label');
    const vmConsolePlaceholder = document.getElementById('vm-console-placeholder');
    const vmConsoleSection = document.getElementById('vm-console-section');
    const vmConsoleTerminalContainer = document.getElementById('vm-console-terminal');
    const vmConsoleOverlay = document.getElementById('vm-console-overlay');
    const vmConsoleConnectButton = document.getElementById('vm-console-connect');
    const vmConsoleDisconnectButton = document.getElementById('vm-console-disconnect');
    const vmConsoleStatus = document.getElementById('vm-console-status');

    let hostInfoTimer = null;
    let terminal = null;
    let fitAddon = null;
    let terminalSocket = null;
    let terminalAgentId = null;
    let closingTerminalState = null;
    let deploymentProfilesInitialised = false;
    let currentDeploymentProfileId = null;
    let vmConsoleTerminal = null;
    let vmConsoleFitAddon = null;
    let vmConsoleSocket = null;
    let vmConsoleClosingState = null;
    let deploymentSummaryTimer = null;
    let deploymentSummaryInFlight = false;
    const deploymentPollTimers = {};
    const textEncoder = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;
    const textDecoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;
    const sshCopyButtonLabel = sshCopyButton ? sshCopyButton.textContent : '';

    function buildUrl(template, agentId, vmName, action) {
        let url = template.replace('/0/', '/' + agentId + '/');
        if (vmName !== undefined) {
            url = url.replace('__VM__', encodeURIComponent(vmName));
        }
        if (action !== undefined) {
            url = url.replace('__ACTION__', action);
        }
        return url;
    }

    function buildWebsocketUrl(template, agentId, vmName) {
        if (!template) {
            return null;
        }
        let replaced = template.replace('/0/', '/' + agentId + '/');
        if (vmName !== undefined) {
            replaced = replaced.replace('__VM__', encodeURIComponent(vmName));
        }
        try {
            const url = new URL(replaced, window.location.href);
            url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
            return url.toString();
        } catch (_) {
            return null;
        }
    }

    function buildDeploymentDetailUrl(template, deploymentId) {
        if (!template) {
            return null;
        }
        try {
            return template.replace('__DEPLOYMENT__', encodeURIComponent(deploymentId));
        } catch (_) {
            return null;
        }
    }

    function showTerminalOverlay(message) {
        if (sshTerminalOverlay) {
            sshTerminalOverlay.textContent = message;
            sshTerminalOverlay.style.display = 'flex';
        }
    }

    function hideTerminalOverlay() {
        if (sshTerminalOverlay) {
            sshTerminalOverlay.style.display = 'none';
        }
    }

    function setTerminalStatus(message, isError = false) {
        if (!sshStatus) {
            return;
        }
        sshStatus.textContent = message;
        if (isError) {
            sshStatus.classList.add('error');
        } else {
            sshStatus.classList.remove('error');
        }
    }

    function setDeploymentStatus(message, isError = false) {
        if (!deploymentStatus) {
            return;
        }
        deploymentStatus.textContent = message;
        deploymentStatus.classList.toggle('error', Boolean(isError));
    }

    function formatTimestamp(value) {
        if (!value) {
            return '—';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
            return value;
        }
        return date.toLocaleString();
    }

    function formatLogTime(value) {
        if (!value) {
            return '—';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
            return value;
        }
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function formatDeploymentStatus(status) {
        const normalized = (status || '').toLowerCase();
        if (normalized === 'pending') {
            return 'Pending';
        }
        if (normalized === 'running') {
            return 'Running';
        }
        if (normalized === 'succeeded') {
            return 'Completed';
        }
        if (normalized === 'failed') {
            return 'Failed';
        }
        return status || 'Unknown';
    }

    function statusToBadgeClass(status) {
        const normalized = (status || '').toLowerCase();
        if (normalized === 'pending') {
            return 'warning';
        }
        if (normalized === 'running') {
            return 'info';
        }
        if (normalized === 'succeeded') {
            return 'success';
        }
        if (normalized === 'failed') {
            return 'danger';
        }
        return '';
    }

    function createMetaItem(label, value) {
        const span = document.createElement('span');
        const strong = document.createElement('strong');
        strong.textContent = `${label}:`;
        span.appendChild(strong);
        span.append(' ', value ?? '—');
        return span;
    }

    function showDeploymentError(message) {
        if (deploymentActivityError) {
            deploymentActivityError.textContent = message;
            deploymentActivityError.style.display = '';
        }
    }

    function hideDeploymentError() {
        if (deploymentActivityError) {
            deploymentActivityError.textContent = '';
            deploymentActivityError.style.display = 'none';
        }
    }

    function clearDeploymentPoll(id) {
        const timer = deploymentPollTimers[id];
        if (timer) {
            window.clearTimeout(timer);
            delete deploymentPollTimers[id];
        }
    }

    function scheduleDeploymentPoll(id, delay = 2000) {
        clearDeploymentPoll(id);
        deploymentPollTimers[id] = window.setTimeout(() => {
            performDeploymentPoll(id);
        }, delay);
    }

    function performDeploymentPoll(id, options = {}) {
        const detail = state.deploymentDetails[id];
        if (!detail) {
            clearDeploymentPoll(id);
            return;
        }
        const fetchOptions = {};
        if (options.full) {
            fetchOptions.full = true;
        } else if (typeof options.after === 'number') {
            fetchOptions.after = options.after;
        } else if (typeof detail.lastSequence === 'number' && detail.lastSequence >= 0) {
            fetchOptions.after = detail.lastSequence;
        }
        fetchDeploymentDetail(id, fetchOptions);
    }

    async function fetchDeploymentDetail(id, options = {}) {
        const detail = state.deploymentDetails[id];
        if (!detail || !state.endpoints || !state.endpoints.deployment_detail) {
            return;
        }
        if (detail.loading) {
            return;
        }

        detail.loading = true;
        let url = buildDeploymentDetailUrl(state.endpoints.deployment_detail, id);
        if (!url) {
            detail.loading = false;
            return;
        }

        const params = new URLSearchParams();
        if (!options.full) {
            const afterValue =
                typeof options.after === 'number'
                    ? options.after
                    : typeof detail.lastSequence === 'number' && detail.lastSequence >= 0
                        ? detail.lastSequence
                        : null;
            if (afterValue !== null && afterValue >= 0) {
                params.set('after', String(afterValue));
            }
        }

        const query = params.toString();
        if (query) {
            url += (url.includes('?') ? '&' : '?') + query;
        }

        try {
            const response = await fetch(url, {
                credentials: 'same-origin',
                cache: 'no-store',
            });
            const payload = await response.json();
            if (!response.ok || !payload || payload.status !== 'ok' || !payload.deployment) {
                throw new Error((payload && payload.message) || 'Failed to load deployment details.');
            }

            const deployment = payload.deployment;
            detail.summary = { ...detail.summary, ...deployment };

            const messages = Array.isArray(deployment.messages) ? deployment.messages : [];
            if (messages.length) {
                if (!Array.isArray(detail.messages)) {
                    detail.messages = [];
                }
                detail.messages = detail.messages.concat(messages);
                if (detail.messages.length > 1000) {
                    detail.messages = detail.messages.slice(-1000);
                }
                const lastMessage = messages[messages.length - 1];
                if (lastMessage && typeof lastMessage.sequence === 'number') {
                    detail.lastSequence = lastMessage.sequence;
                }
            } else if (typeof deployment.next_sequence === 'number') {
                detail.lastSequence = deployment.next_sequence - 1;
            }

            const index = state.deployments.findIndex((item) => item && item.id === deployment.id);
            if (index !== -1) {
                state.deployments[index] = { ...state.deployments[index], ...deployment };
            }

            detail.error = null;
            detail.initialised = true;
            renderDeploymentActivity();

            if (deployment.status === 'running' || deployment.status === 'pending') {
                scheduleDeploymentPoll(id);
            } else {
                clearDeploymentPoll(id);
            }
        } catch (error) {
            detail.error = error.message || 'Failed to load deployment details.';
            renderDeploymentActivity();
            scheduleDeploymentPoll(id, 5000);
        } finally {
            detail.loading = false;
        }
    }

    function renderDeploymentActivity() {
        if (!deploymentActivityContainer || !deploymentActivityEmpty) {
            return;
        }

        const deployments = Array.isArray(state.deployments) ? state.deployments : [];
        if (!deployments.length) {
            deploymentActivityContainer.style.display = 'none';
            deploymentActivityContainer.innerHTML = '';
            deploymentActivityEmpty.style.display = '';
            return;
        }

        deploymentActivityEmpty.style.display = 'none';
        deploymentActivityContainer.style.display = '';
        deploymentActivityContainer.innerHTML = '';

        const fragment = document.createDocumentFragment();
        deployments.forEach((summary) => {
            if (!summary || !summary.id) {
                return;
            }
            const detail = state.deploymentDetails[summary.id] || {
                messages: [],
                summary,
            };

            const entry = document.createElement('div');
            entry.className = 'deployment-entry';

            const header = document.createElement('div');
            header.className = 'deployment-entry-header';
            const title = document.createElement('h3');
            title.textContent = summary.vm_name || summary.id;
            header.appendChild(title);
            const badge = document.createElement('span');
            const badgeClass = statusToBadgeClass(summary.status);
            badge.className = 'badge' + (badgeClass ? ' ' + badgeClass : '');
            badge.textContent = formatDeploymentStatus(summary.status);
            header.appendChild(badge);
            entry.appendChild(header);

            const meta = document.createElement('div');
            meta.className = 'deployment-meta';
            meta.appendChild(createMetaItem('Agent', summary.agent_name || `#${summary.agent_id}`));
            if (summary.profile_name) {
                meta.appendChild(createMetaItem('Profile', summary.profile_name));
            }
            if (summary.parameters && typeof summary.parameters.memory_mb === 'number') {
                meta.appendChild(createMetaItem('Memory', `${summary.parameters.memory_mb} MiB`));
            }
            if (summary.parameters && typeof summary.parameters.vcpus === 'number') {
                meta.appendChild(createMetaItem('vCPUs', summary.parameters.vcpus));
            }
            if (summary.parameters && typeof summary.parameters.disk_gb === 'number') {
                meta.appendChild(createMetaItem('Disk', `${summary.parameters.disk_gb} GiB`));
            }
            meta.appendChild(createMetaItem('Queued', formatTimestamp(summary.created_at)));
            meta.appendChild(createMetaItem('Updated', formatTimestamp(summary.updated_at)));
            if (typeof summary.exit_status === 'number' && summary.status && summary.status.toLowerCase() !== 'running' && summary.status.toLowerCase() !== 'pending') {
                meta.appendChild(createMetaItem('Exit status', summary.exit_status));
            }
            entry.appendChild(meta);

            if (detail && detail.error) {
                const errorNotice = document.createElement('div');
                errorNotice.className = 'notice danger';
                errorNotice.textContent = detail.error;
                entry.appendChild(errorNotice);
            }

            const logOutput = document.createElement('div');
            logOutput.className = 'deployment-log-output';
            const messages = detail && Array.isArray(detail.messages) ? detail.messages : [];
            if (messages.length) {
                messages.forEach((message) => {
                    if (!message) {
                        return;
                    }
                    const line = document.createElement('div');
                    line.className = 'deployment-log-line';
                    if (message.stream) {
                        line.dataset.stream = message.stream;
                    }
                    const timestamp = document.createElement('div');
                    timestamp.className = 'deployment-log-time';
                    timestamp.textContent = formatLogTime(message.timestamp);
                    const text = document.createElement('div');
                    text.textContent = message.message || '';
                    line.appendChild(timestamp);
                    line.appendChild(text);
                    logOutput.appendChild(line);
                });
            } else {
                const placeholder = document.createElement('div');
                placeholder.className = 'deployment-log-empty';
                if (detail && detail.loading) {
                    placeholder.textContent = 'Loading deployment logs…';
                } else if (summary.status && summary.status.toLowerCase() === 'failed') {
                    placeholder.textContent = 'Deployment failed before producing log output.';
                } else if (summary.status && summary.status.toLowerCase() === 'succeeded') {
                    placeholder.textContent = 'Deployment completed without log output.';
                } else {
                    placeholder.textContent = 'No log output yet.';
                }
                logOutput.appendChild(placeholder);
            }
            entry.appendChild(logOutput);

            fragment.appendChild(entry);
        });

        deploymentActivityContainer.appendChild(fragment);
    }

    function scheduleDeploymentSummaryRefresh(delay = 20000) {
        if (deploymentSummaryTimer !== null) {
            window.clearTimeout(deploymentSummaryTimer);
        }
        deploymentSummaryTimer = window.setTimeout(() => {
            refreshDeploymentSummaries();
        }, delay);
    }

    async function refreshDeploymentSummaries(options = {}) {
        if (!state.endpoints || !state.endpoints.deployment_logs) {
            return;
        }
        if (deploymentSummaryInFlight) {
            return;
        }
        deploymentSummaryInFlight = true;
        if (deploymentSummaryTimer !== null) {
            window.clearTimeout(deploymentSummaryTimer);
            deploymentSummaryTimer = null;
        }

        try {
            const response = await fetch(state.endpoints.deployment_logs, {
                credentials: 'same-origin',
                cache: 'no-store',
            });
            const payload = await response.json();
            if (!response.ok || !payload || payload.status !== 'ok') {
                throw new Error((payload && payload.message) || 'Failed to load deployments.');
            }

            const deployments = Array.isArray(payload.deployments) ? payload.deployments.slice() : [];
            deployments.sort((a, b) => {
                const aTime = new Date(a && a.created_at ? a.created_at : 0).getTime();
                const bTime = new Date(b && b.created_at ? b.created_at : 0).getTime();
                return bTime - aTime;
            });
            state.deployments = deployments;

            const seen = new Set();
            deployments.forEach((summary) => {
                if (!summary || !summary.id) {
                    return;
                }
                seen.add(summary.id);
                const detail = state.deploymentDetails[summary.id];
                if (detail) {
                    detail.summary = { ...detail.summary, ...summary };
                } else {
                    state.deploymentDetails[summary.id] = {
                        summary: { ...summary },
                        messages: [],
                        lastSequence: -1,
                        error: null,
                        loading: false,
                        initialised: false,
                    };
                }
            });

            Object.keys(state.deploymentDetails).forEach((id) => {
                if (!seen.has(id)) {
                    clearDeploymentPoll(id);
                    delete state.deploymentDetails[id];
                }
            });

            hideDeploymentError();
            renderDeploymentActivity();

            deployments.forEach((summary) => {
                if (!summary || !summary.id) {
                    return;
                }
                const detail = state.deploymentDetails[summary.id];
                if (!detail) {
                    return;
                }
                if (!detail.initialised) {
                    detail.initialised = true;
                    fetchDeploymentDetail(summary.id, { full: true });
                } else if (summary.status === 'running' || summary.status === 'pending') {
                    scheduleDeploymentPoll(summary.id);
                }
            });
        } catch (error) {
            showDeploymentError(error.message || 'Failed to load deployments.');
            renderDeploymentActivity();
        } finally {
            deploymentSummaryInFlight = false;
            scheduleDeploymentSummaryRefresh(options.manual ? 20000 : 20000);
        }
    }

    function findDeploymentProfile(profileId) {
        if (!Array.isArray(state.deploymentProfiles)) {
            return null;
        }
        return state.deploymentProfiles.find((profile) => profile && profile.id === profileId) || null;
    }

    function populateDeploymentProfiles() {
        if (!deploymentProfileSelect || deploymentProfilesInitialised) {
            return;
        }
        const profiles = Array.isArray(state.deploymentProfiles) ? state.deploymentProfiles : [];
        deploymentProfileSelect.innerHTML = '';
        const fragment = document.createDocumentFragment();
        profiles.forEach((profile) => {
            if (!profile || !profile.id) {
                return;
            }
            const option = document.createElement('option');
            option.value = profile.id;
            option.textContent = profile.name || profile.id;
            fragment.appendChild(option);
        });
        deploymentProfileSelect.appendChild(fragment);
        deploymentProfilesInitialised = true;
        if (profiles.length && !currentDeploymentProfileId) {
            currentDeploymentProfileId = profiles[0].id;
        }
    }

    function updateDeploymentProfileDetails(profile, options = {}) {
        const { resetValues = false } = options;

        if (!profile) {
            currentDeploymentProfileId = null;
            if (deploymentDescription) {
                deploymentDescription.textContent = 'No deployment profiles available.';
            }
            if (deploymentSourceLink) {
                deploymentSourceLink.removeAttribute('href');
                deploymentSourceLink.textContent = 'Not available';
            }
            if (deploymentDownloadLink) {
                deploymentDownloadLink.removeAttribute('href');
                deploymentDownloadLink.textContent = 'Unavailable';
            }
            if (deploymentUsername) {
                deploymentUsername.value = '';
                deploymentUsername.placeholder = deploymentUsernameDefaultPlaceholder;
            }
            if (deploymentPassword) {
                deploymentPassword.value = '';
                deploymentPassword.placeholder = deploymentPasswordDefaultPlaceholder;
            }
            if (deploymentVariant) {
                deploymentVariant.textContent = '—';
            }
            if (deploymentNotes) {
                deploymentNotes.textContent = '';
            }
            return;
        }

        currentDeploymentProfileId = profile.id;
        if (deploymentProfileSelect && deploymentProfileSelect.value !== profile.id) {
            deploymentProfileSelect.value = profile.id;
        }
        if (deploymentDescription) {
            deploymentDescription.textContent = profile.description || '';
        }
        if (deploymentSourceLink) {
            if (profile.source_url) {
                deploymentSourceLink.href = profile.source_url;
                deploymentSourceLink.textContent = 'View documentation';
            } else {
                deploymentSourceLink.removeAttribute('href');
                deploymentSourceLink.textContent = 'Not available';
            }
        }
        if (deploymentDownloadLink) {
            if (profile.download_url) {
                deploymentDownloadLink.href = profile.download_url;
                deploymentDownloadLink.textContent = 'Open image';
            } else {
                deploymentDownloadLink.removeAttribute('href');
                deploymentDownloadLink.textContent = 'Unavailable';
            }
        }
        if (deploymentUsername) {
            if (resetValues) {
                deploymentUsername.value = profile.default_username || '';
            }
            deploymentUsername.placeholder = profile.default_username || deploymentUsernameDefaultPlaceholder;
        }
        if (deploymentPassword) {
            if (resetValues) {
                deploymentPassword.value = profile.default_password || '';
            }
            deploymentPassword.placeholder = profile.default_password || deploymentPasswordDefaultPlaceholder;
        }
        if (deploymentVariant) {
            deploymentVariant.textContent = profile.os_variant || '—';
        }
        if (deploymentNotes) {
            deploymentNotes.textContent = profile.notes || '';
        }
        if (resetValues) {
            if (deploymentMemoryInput) {
                deploymentMemoryInput.value = profile.default_memory_mb || '';
            }
            if (deploymentVcpusInput) {
                deploymentVcpusInput.value = profile.default_vcpus || '';
            }
            if (deploymentDiskInput) {
                deploymentDiskInput.value = profile.default_disk_gb || '';
            }
        }
    }

    function updateDeploymentSection(agent) {
        if (!deploymentPlaceholder || !deploymentSection) {
            return;
        }

        if (deploymentAgentBadge) {
            deploymentAgentBadge.textContent = agent ? agent.name : 'No agent selected';
        }

        if (!Array.isArray(state.deploymentProfiles) || !state.deploymentProfiles.length) {
            deploymentPlaceholder.style.display = '';
            deploymentPlaceholder.textContent = 'No deployment profiles are available for this environment.';
            deploymentSection.style.display = 'none';
            setDeploymentStatus('No deployment profiles available.', true);
            return;
        }

        populateDeploymentProfiles();

        if (!agent) {
            deploymentSection.style.display = 'none';
            deploymentPlaceholder.style.display = '';
            deploymentPlaceholder.textContent = state.agents.length
                ? 'Select a hypervisor to prepare an automated operating system installation.'
                : 'Pair a hypervisor with the agent service to enable guided VM deployments.';
            setDeploymentStatus('Select a hypervisor to deploy.', false);
            return;
        }

        deploymentPlaceholder.style.display = 'none';
        deploymentSection.style.display = '';
        const profile = findDeploymentProfile(currentDeploymentProfileId) || state.deploymentProfiles[0] || null;
        updateDeploymentProfileDetails(profile, { resetValues: true });
        setDeploymentStatus('Ready to deploy.', false);
    }

    function ensureTerminal() {
        if (terminal || !sshTerminalContainer) {
            return;
        }
        if (typeof window.Terminal !== 'function') {
            showTerminalOverlay('Terminal library failed to load.');
            setTerminalStatus('Browser terminal unavailable.', true);
            return;
        }
        terminal = new window.Terminal({
            convertEol: true,
            cursorBlink: true,
            fontFamily: 'JetBrains Mono, SFMono-Regular, Menlo, Consolas, "Liberation Mono", Courier, monospace',
            fontSize: 14,
            theme: {
                background: '#0f172a',
                foreground: '#f8fafc',
            },
        });
        if (window.FitAddon && typeof window.FitAddon.FitAddon === 'function') {
            fitAddon = new window.FitAddon.FitAddon();
            terminal.loadAddon(fitAddon);
        }
        terminal.open(sshTerminalContainer);
        if (fitAddon) {
            fitAddon.fit();
        }
        terminal.focus();
        terminal.onData((data) => {
            if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
                if (textEncoder) {
                    terminalSocket.send(textEncoder.encode(data));
                } else {
                    terminalSocket.send(data);
                }
            }
        });
    }

    function clearTerminal() {
        if (terminal) {
            terminal.reset();
        }
    }

    function sendTerminalResize() {
        if (!terminal || !terminalSocket || terminalSocket.readyState !== WebSocket.OPEN) {
            return;
        }
        const payload = {
            type: 'resize',
            cols: terminal.cols,
            rows: terminal.rows,
        };
        try {
            terminalSocket.send(JSON.stringify(payload));
        } catch (_) {
            // ignore transmission errors
        }
    }

    function disconnectTerminal(showMessage = true) {
        if (!terminalSocket) {
            if (showMessage) {
                setTerminalStatus('Disconnected.');
                showTerminalOverlay('Session disconnected.');
            }
            if (sshDisconnectButton) {
                sshDisconnectButton.setAttribute('disabled', 'true');
            }
            if (sshConnectButton) {
                if (state.selectedAgent) {
                    sshConnectButton.removeAttribute('disabled');
                } else {
                    sshConnectButton.setAttribute('disabled', 'true');
                }
            }
            if (sshCopyButton) {
                if (sshCopyButtonLabel) {
                    sshCopyButton.textContent = sshCopyButtonLabel;
                }
                if (state.selectedAgent) {
                    sshCopyButton.removeAttribute('disabled');
                } else {
                    sshCopyButton.setAttribute('disabled', 'true');
                }
            }
            terminalAgentId = null;
            return;
        }
        closingTerminalState = showMessage ? 'manual' : 'silent';
        const socket = terminalSocket;
        terminalSocket = null;
        try {
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'close' }));
            }
            socket.close();
        } catch (_) {
            // ignore close failures
        }
    }

    function connectTerminal(agent) {
        if (!agent) {
            return;
        }

        ensureTerminal();
        if (!terminal) {
            setTerminalStatus('Browser terminal unavailable.', true);
            showTerminalOverlay('Unable to initialize terminal component.');
            return;
        }

        if (!state.endpoints || !state.endpoints.ssh_terminal) {
            setTerminalStatus('Terminal endpoint is not configured.', true);
            showTerminalOverlay('Terminal endpoint is not available.');
            return;
        }

        const websocketUrl = buildWebsocketUrl(state.endpoints.ssh_terminal, agent.id);
        if (!websocketUrl) {
            setTerminalStatus('Terminal endpoint is not configured.', true);
            showTerminalOverlay('Terminal endpoint is not available.');
            return;
        }

        if (terminalSocket) {
            if (terminalAgentId === agent.id && terminalSocket.readyState === WebSocket.OPEN) {
                return;
            }
            disconnectTerminal(false);
        }

        closingTerminalState = null;
        terminalAgentId = agent.id;
        setTerminalStatus(`Connecting to ${agent.hostname}…`);
        showTerminalOverlay(`Connecting to ${agent.hostname}…`);

        if (sshConnectButton) {
            sshConnectButton.setAttribute('disabled', 'true');
        }
        if (sshDisconnectButton) {
            sshDisconnectButton.removeAttribute('disabled');
        }
        if (sshCopyButton) {
            sshCopyButton.removeAttribute('disabled');
        }

        clearTerminal();

        try {
            terminalSocket = new WebSocket(websocketUrl);
        } catch (_) {
            terminalSocket = null;
            setTerminalStatus('Failed to connect.', true);
            showTerminalOverlay('Failed to establish SSH session.');
            if (sshConnectButton) {
                sshConnectButton.removeAttribute('disabled');
            }
            if (sshDisconnectButton) {
                sshDisconnectButton.setAttribute('disabled', 'true');
            }
            return;
        }

        terminalSocket.binaryType = 'arraybuffer';

        terminalSocket.addEventListener('open', () => {
            setTerminalStatus(`Connected to ${agent.hostname}`);
            hideTerminalOverlay();
            if (fitAddon) {
                fitAddon.fit();
            }
            sendTerminalResize();
        });

        terminalSocket.addEventListener('message', (event) => {
            if (typeof event.data === 'string') {
                try {
                    const payload = JSON.parse(event.data);
                    if (payload.type === 'status' && payload.status === 'connected') {
                        hideTerminalOverlay();
                        return;
                    }
                    if (payload.type === 'error') {
                        setTerminalStatus(payload.message || 'SSH session error.', true);
                        showTerminalOverlay(payload.message || 'SSH session error.');
                    }
                } catch (_) {
                    // ignore non-JSON control messages
                }
                return;
            }

            if (event.data instanceof ArrayBuffer && terminal) {
                let text = '';
                if (textDecoder) {
                    text = textDecoder.decode(event.data);
                } else {
                    const view = new Uint8Array(event.data);
                    text = Array.from(view).map((code) => String.fromCharCode(code)).join('');
                }
                terminal.write(text);
            }
        });

        terminalSocket.addEventListener('close', () => {
            const mode = closingTerminalState;
            closingTerminalState = null;
            terminalSocket = null;
            terminalAgentId = null;
            if (sshDisconnectButton) {
                sshDisconnectButton.setAttribute('disabled', 'true');
            }
            if (sshConnectButton) {
                if (state.selectedAgent) {
                    sshConnectButton.removeAttribute('disabled');
                } else {
                    sshConnectButton.setAttribute('disabled', 'true');
                }
            }
            if (sshCopyButton) {
                if (sshCopyButtonLabel) {
                    sshCopyButton.textContent = sshCopyButtonLabel;
                }
                if (state.selectedAgent) {
                    sshCopyButton.removeAttribute('disabled');
                } else {
                    sshCopyButton.setAttribute('disabled', 'true');
                }
            }
            if (mode !== 'silent') {
                setTerminalStatus('Disconnected.');
                showTerminalOverlay('Session disconnected.');
            }
        });

        terminalSocket.addEventListener('error', () => {
            setTerminalStatus('Failed to connect.', true);
            showTerminalOverlay('Failed to establish SSH session.');
        });
    }

    function ensureVmTerminal() {
        if (vmConsoleTerminal || !vmConsoleTerminalContainer) {
            return;
        }
        if (typeof window.Terminal !== 'function') {
            showVmConsoleOverlay('Terminal library failed to load.');
            setVmConsoleStatus('Browser console unavailable.', true);
            return;
        }
        vmConsoleTerminal = new window.Terminal({
            convertEol: true,
            cursorBlink: true,
            fontFamily: 'JetBrains Mono, SFMono-Regular, Menlo, Consolas, "Liberation Mono", Courier, monospace',
            fontSize: 14,
            theme: {
                background: '#0f172a',
                foreground: '#f8fafc',
            },
        });
        if (window.FitAddon && typeof window.FitAddon.FitAddon === 'function') {
            vmConsoleFitAddon = new window.FitAddon.FitAddon();
            vmConsoleTerminal.loadAddon(vmConsoleFitAddon);
        }
        vmConsoleTerminal.open(vmConsoleTerminalContainer);
        if (vmConsoleFitAddon) {
            vmConsoleFitAddon.fit();
        }
        vmConsoleTerminal.focus();
        vmConsoleTerminal.onData((data) => {
            if (vmConsoleSocket && vmConsoleSocket.readyState === WebSocket.OPEN) {
                if (textEncoder) {
                    vmConsoleSocket.send(textEncoder.encode(data));
                } else {
                    vmConsoleSocket.send(data);
                }
            }
        });
    }

    function clearVmTerminal() {
        if (vmConsoleTerminal) {
            vmConsoleTerminal.reset();
        }
    }

    function showVmConsoleOverlay(message) {
        if (vmConsoleOverlay) {
            vmConsoleOverlay.textContent = message;
            vmConsoleOverlay.style.display = 'flex';
        }
    }

    function hideVmConsoleOverlay() {
        if (vmConsoleOverlay) {
            vmConsoleOverlay.style.display = 'none';
        }
    }

    function setVmConsoleStatus(message, isError = false) {
        if (!vmConsoleStatus) {
            return;
        }
        vmConsoleStatus.textContent = message;
        if (isError) {
            vmConsoleStatus.classList.add('error');
        } else {
            vmConsoleStatus.classList.remove('error');
        }
    }

    function sendVmConsoleResize() {
        if (!vmConsoleTerminal || !vmConsoleSocket || vmConsoleSocket.readyState !== WebSocket.OPEN) {
            return;
        }
        const payload = {
            type: 'resize',
            cols: vmConsoleTerminal.cols,
            rows: vmConsoleTerminal.rows,
        };
        try {
            vmConsoleSocket.send(JSON.stringify(payload));
        } catch (_) {
            // ignore transmission errors
        }
    }

    function disconnectVmConsole(showMessage = true) {
        if (!vmConsoleSocket) {
            if (showMessage) {
                setVmConsoleStatus('Disconnected.');
                showVmConsoleOverlay('Console disconnected.');
            }
            if (vmConsoleDisconnectButton) {
                vmConsoleDisconnectButton.setAttribute('disabled', 'true');
            }
            if (vmConsoleConnectButton) {
                if (state.selectedAgent && state.selectedVm) {
                    vmConsoleConnectButton.removeAttribute('disabled');
                } else {
                    vmConsoleConnectButton.setAttribute('disabled', 'true');
                }
            }
            vmConsoleClosingState = null;
            return;
        }
        vmConsoleClosingState = showMessage ? 'manual' : 'silent';
        const socket = vmConsoleSocket;
        vmConsoleSocket = null;
        try {
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'close' }));
            }
            socket.close();
        } catch (_) {
            // ignore close failures
        }
    }

    function connectVmConsole() {
        const agent = state.selectedAgent;
        const vm = state.selectedVm;
        if (!agent || !vm) {
            return;
        }

        ensureVmTerminal();
        if (!vmConsoleTerminal) {
            setVmConsoleStatus('Browser console unavailable.', true);
            showVmConsoleOverlay('Unable to initialize console component.');
            return;
        }

        if (!state.endpoints || !state.endpoints.vm_console) {
            setVmConsoleStatus('Console endpoint is not configured.', true);
            showVmConsoleOverlay('Console endpoint is not available.');
            return;
        }

        const websocketUrl = buildWebsocketUrl(state.endpoints.vm_console, agent.id, vm.name);
        if (!websocketUrl) {
            setVmConsoleStatus('Console endpoint is not configured.', true);
            showVmConsoleOverlay('Console endpoint is not available.');
            return;
        }

        if (vmConsoleSocket) {
            if (
                vmConsoleSocket.readyState === WebSocket.OPEN &&
                vmConsoleClosingState === null &&
                state.selectedVm &&
                state.selectedVm.name === vm.name
            ) {
                return;
            }
            disconnectVmConsole(false);
        }

        vmConsoleClosingState = null;
        setVmConsoleStatus(`Connecting to ${vm.name}…`);
        showVmConsoleOverlay(`Connecting to ${vm.name}…`);
        if (vmConsoleConnectButton) {
            vmConsoleConnectButton.setAttribute('disabled', 'true');
        }
        if (vmConsoleDisconnectButton) {
            vmConsoleDisconnectButton.removeAttribute('disabled');
        }

        clearVmTerminal();

        try {
            vmConsoleSocket = new WebSocket(websocketUrl);
        } catch (_) {
            vmConsoleSocket = null;
            setVmConsoleStatus('Failed to connect.', true);
            showVmConsoleOverlay('Failed to establish console session.');
            if (vmConsoleConnectButton) {
                vmConsoleConnectButton.removeAttribute('disabled');
            }
            if (vmConsoleDisconnectButton) {
                vmConsoleDisconnectButton.setAttribute('disabled', 'true');
            }
            return;
        }

        vmConsoleSocket.binaryType = 'arraybuffer';

        vmConsoleSocket.addEventListener('open', () => {
            setVmConsoleStatus(`Connected to ${vm.name}`);
            hideVmConsoleOverlay();
            if (vmConsoleFitAddon) {
                vmConsoleFitAddon.fit();
            }
            sendVmConsoleResize();
        });

        vmConsoleSocket.addEventListener('message', (event) => {
            if (typeof event.data === 'string') {
                try {
                    const payload = JSON.parse(event.data);
                    if (payload.type === 'status' && payload.status === 'connected') {
                        hideVmConsoleOverlay();
                        return;
                    }
                    if (payload.type === 'error') {
                        setVmConsoleStatus(payload.message || 'Console session error.', true);
                        showVmConsoleOverlay(payload.message || 'Console session error.');
                    }
                } catch (_) {
                    // ignore non-JSON control messages
                }
                return;
            }

            if (event.data instanceof ArrayBuffer && vmConsoleTerminal) {
                let text = '';
                if (textDecoder) {
                    text = textDecoder.decode(event.data);
                } else {
                    const view = new Uint8Array(event.data);
                    text = Array.from(view).map((code) => String.fromCharCode(code)).join('');
                }
                vmConsoleTerminal.write(text);
            }
        });

        vmConsoleSocket.addEventListener('close', () => {
            const mode = vmConsoleClosingState;
            vmConsoleClosingState = null;
            vmConsoleSocket = null;
            if (vmConsoleDisconnectButton) {
                vmConsoleDisconnectButton.setAttribute('disabled', 'true');
            }
            if (vmConsoleConnectButton) {
                if (state.selectedAgent && state.selectedVm) {
                    vmConsoleConnectButton.removeAttribute('disabled');
                } else {
                    vmConsoleConnectButton.setAttribute('disabled', 'true');
                }
            }
            if (mode !== 'silent') {
                setVmConsoleStatus('Disconnected.');
                showVmConsoleOverlay('Console disconnected.');
            }
        });

        vmConsoleSocket.addEventListener('error', () => {
            setVmConsoleStatus('Failed to connect.', true);
            showVmConsoleOverlay('Failed to establish console session.');
        });
    }

    function selectVm(vm) {
        if (!vm) {
            if (state.selectedVm) {
                state.selectedVm = null;
                updateVmConsoleSection();
                renderVmTable();
            }
            return;
        }
        state.selectedVm = { ...vm };
        renderVmTable();
        updateVmConsoleSection();
    }

    function updateVmConsoleSection() {
        if (!vmConsolePlaceholder || !vmConsoleSection) {
            return;
        }
        const agent = state.selectedAgent;
        const vm = state.selectedVm;

        if (!agent) {
            vmConsolePlaceholder.style.display = '';
            vmConsolePlaceholder.textContent = state.agents.length
                ? 'Select a hypervisor and choose a VM to open its console.'
                : 'Pair a hypervisor with the agent service to access guest consoles.';
            vmConsoleSection.style.display = 'none';
            disconnectVmConsole(false);
            if (vmConsoleLabel) {
                vmConsoleLabel.textContent = 'Unavailable';
            }
            return;
        }

        vmConsoleSection.style.display = '';
        if (vmConsoleLabel) {
            vmConsoleLabel.textContent = vm ? vm.name : 'No VM selected';
        }

        if (!vm) {
            vmConsolePlaceholder.style.display = '';
            vmConsolePlaceholder.textContent = 'Select a virtual machine from the inventory to open its console.';
            showVmConsoleOverlay('Select a virtual machine to connect.');
            setVmConsoleStatus('Disconnected.');
            if (vmConsoleConnectButton) {
                vmConsoleConnectButton.setAttribute('disabled', 'true');
            }
            if (vmConsoleDisconnectButton) {
                vmConsoleDisconnectButton.setAttribute('disabled', 'true');
            }
            return;
        }

        vmConsolePlaceholder.style.display = 'none';
        const connected = vmConsoleSocket && vmConsoleSocket.readyState === WebSocket.OPEN;
        if (connected) {
            hideVmConsoleOverlay();
            setVmConsoleStatus(`Connected to ${vm.name}`);
            if (vmConsoleConnectButton) {
                vmConsoleConnectButton.setAttribute('disabled', 'true');
            }
            if (vmConsoleDisconnectButton) {
                vmConsoleDisconnectButton.removeAttribute('disabled');
            }
        } else {
            showVmConsoleOverlay(`Click Connect to open ${vm.name}.`);
            setVmConsoleStatus('Ready to connect.');
            if (vmConsoleConnectButton) {
                vmConsoleConnectButton.removeAttribute('disabled');
            }
            if (vmConsoleDisconnectButton) {
                vmConsoleDisconnectButton.setAttribute('disabled', 'true');
            }
            clearVmTerminal();
            ensureVmTerminal();
            if (vmConsoleFitAddon) {
                requestAnimationFrame(() => {
                    vmConsoleFitAddon.fit();
                    sendVmConsoleResize();
                });
            }
        }
    }

    if (sshConnectButton) {
        sshConnectButton.addEventListener('click', () => {
            if (state.selectedAgent) {
                connectTerminal(state.selectedAgent);
            }
        });
    }

    if (sshDisconnectButton) {
        sshDisconnectButton.addEventListener('click', () => {
            disconnectTerminal();
        });
    }

    if (sshCopyButton) {
        sshCopyButton.addEventListener('click', async () => {
            if (!sshCommand) {
                return;
            }
            const text = (sshCommand.textContent || '').trim();
            if (!text) {
                return;
            }

            const restoreLabel = () => {
                if (sshCopyButtonLabel) {
                    sshCopyButton.textContent = sshCopyButtonLabel;
                }
            };

            const indicateCopied = () => {
                sshCopyButton.textContent = 'Copied!';
                window.setTimeout(() => {
                    restoreLabel();
                }, 1500);
            };

            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    indicateCopied();
                    return;
                }
            } catch (_) {
                // Fallback to execCommand below
            }

            try {
                const helper = document.createElement('textarea');
                helper.value = text;
                helper.style.position = 'fixed';
                helper.style.opacity = '0';
                helper.style.pointerEvents = 'none';
                document.body.appendChild(helper);
                helper.focus();
                helper.select();
                const successful = document.execCommand('copy');
                document.body.removeChild(helper);
                if (successful) {
                    indicateCopied();
                    return;
                }
            } catch (_) {
                // ignore failures and fall through to status update
            }

            setTerminalStatus('Unable to copy command.', true);
            window.setTimeout(() => {
                restoreLabel();
            }, 1500);
        });
    }

    if (vmConsoleConnectButton) {
        vmConsoleConnectButton.addEventListener('click', () => {
            connectVmConsole();
        });
    }

    if (vmConsoleDisconnectButton) {
        vmConsoleDisconnectButton.addEventListener('click', () => {
            disconnectVmConsole();
        });
    }

    if (deploymentProfileSelect) {
        deploymentProfileSelect.addEventListener('change', () => {
            const selectedId = deploymentProfileSelect.value;
            const profile = findDeploymentProfile(selectedId);
            if (profile) {
                updateDeploymentProfileDetails(profile, { resetValues: true });
                setDeploymentStatus('Ready to deploy.', false);
            } else {
                setDeploymentStatus('Select an operating system to deploy.', true);
            }
        });
    }

    if (deploymentRefreshButton) {
        deploymentRefreshButton.addEventListener('click', () => {
            refreshDeploymentSummaries({ manual: true });
        });
    }

    if (deploymentForm) {
        deploymentForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const agent = state.selectedAgent;
            if (!agent) {
                setDeploymentStatus('Select a hypervisor before deploying.', true);
                return;
            }
            if (!state.endpoints || !state.endpoints.deploy_vm) {
                setDeploymentStatus('Deployment endpoint is not configured.', true);
                return;
            }

            const profileId = currentDeploymentProfileId || (deploymentProfileSelect ? deploymentProfileSelect.value : null);
            const profile = findDeploymentProfile(profileId);
            if (!profileId || !profile) {
                setDeploymentStatus('Select an operating system to deploy.', true);
                return;
            }

            const vmName = deploymentNameInput ? deploymentNameInput.value.trim() : '';
            if (!vmName) {
                setDeploymentStatus('Enter a name for the virtual machine.', true);
                if (deploymentNameInput) {
                    deploymentNameInput.focus();
                }
                return;
            }

            const payload = {
                profile_id: profileId,
                vm_name: vmName,
                memory_mb: deploymentMemoryInput ? deploymentMemoryInput.value : undefined,
                vcpus: deploymentVcpusInput ? deploymentVcpusInput.value : undefined,
                disk_gb: deploymentDiskInput ? deploymentDiskInput.value : undefined,
                username: deploymentUsername ? deploymentUsername.value.trim() || undefined : undefined,
                password: deploymentPassword ? deploymentPassword.value || undefined : undefined,
            };

            setDeploymentStatus(`Starting deployment on ${agent.name}…`);
            const submitButton = deploymentForm.querySelector('button[type="submit"]');
            if (submitButton) {
                submitButton.setAttribute('disabled', 'true');
            }

            try {
                const url = buildUrl(state.endpoints.deploy_vm, agent.id);
                const response = await fetch(url, {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const result = await response.json();
                if (!response.ok || result.status !== 'ok') {
                    const message = (result && result.message) || 'Deployment failed.';
                    throw new Error(message);
                }
                setDeploymentStatus(result.message || `Deployment for '${vmName}' started.`, false);
                if (result.deployment_id) {
                    refreshDeploymentSummaries({ manual: true });
                }
                if (result.credentials) {
                    if (deploymentUsername && result.credentials.username) {
                        deploymentUsername.value = result.credentials.username;
                        deploymentUsername.placeholder = result.credentials.username;
                    }
                    if (deploymentPassword && result.credentials.password) {
                        deploymentPassword.value = result.credentials.password;
                        deploymentPassword.placeholder = result.credentials.password;
                    }
                } else if (result.profile) {
                    if (deploymentUsername && result.profile.default_username) {
                        deploymentUsername.value = result.profile.default_username;
                        deploymentUsername.placeholder = result.profile.default_username;
                    }
                    if (deploymentPassword && result.profile.default_password) {
                        deploymentPassword.value = result.profile.default_password;
                        deploymentPassword.placeholder = result.profile.default_password;
                    }
                }
                await fetchVms(agent);
            } catch (error) {
                const message = (error && error.message) || 'Deployment failed.';
                setDeploymentStatus(message, true);
            } finally {
                if (submitButton) {
                    submitButton.removeAttribute('disabled');
                }
            }
        });
    }

    window.addEventListener('resize', () => {
        if (fitAddon) {
            fitAddon.fit();
            sendTerminalResize();
        }
        if (vmConsoleFitAddon) {
            vmConsoleFitAddon.fit();
            sendVmConsoleResize();
        }
    });

    window.addEventListener('beforeunload', () => {
        disconnectTerminal(false);
        disconnectVmConsole(false);
        if (deploymentSummaryTimer !== null) {
            window.clearTimeout(deploymentSummaryTimer);
            deploymentSummaryTimer = null;
        }
        Object.keys(deploymentPollTimers).forEach((id) => {
            clearDeploymentPoll(id);
        });
    });

    function clearHostInfoTimer() {
        if (hostInfoTimer !== null) {
            clearTimeout(hostInfoTimer);
            hostInfoTimer = null;
        }
    }

    function isFiniteNumber(value) {
        return typeof value === 'number' && Number.isFinite(value);
    }

    function humanizeBytes(bytes) {
        if (!isFiniteNumber(bytes)) {
            return 'Unavailable';
        }
        const units = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'];
        let index = 0;
        let value = bytes;
        while (value >= 1024 && index < units.length - 1) {
            value /= 1024;
            index += 1;
        }
        const precision = value >= 10 || index === 0 ? 0 : 1;
        return `${value.toFixed(precision)} ${units[index]}`;
    }

    function parseNodeinfoMemory(value) {
        if (typeof value !== 'string') {
            return null;
        }
        const match = value.match(/([0-9.]+)\s*KiB/i);
        if (!match) {
            return null;
        }
        const parsed = parseFloat(match[1]);
        if (!Number.isFinite(parsed)) {
            return null;
        }
        return parsed * 1024;
    }

    function formatNodeinfoMemory(value) {
        const bytes = parseNodeinfoMemory(value);
        if (bytes === null) {
            return value || 'Unavailable';
        }
        return humanizeBytes(bytes);
    }

    function formatLoadAverage(load) {
        if (!load || !isFiniteNumber(load.one) || !isFiniteNumber(load.five) || !isFiniteNumber(load.fifteen)) {
            return 'Unavailable';
        }
        return `${load.one.toFixed(2)} / ${load.five.toFixed(2)} / ${load.fifteen.toFixed(2)}`;
    }

    function formatMemoryUsage(memory) {
        if (!memory || !isFiniteNumber(memory.total_bytes) || !isFiniteNumber(memory.used_bytes)) {
            return 'Unavailable';
        }
        const used = humanizeBytes(memory.used_bytes);
        const total = humanizeBytes(memory.total_bytes);
        const percentText = isFiniteNumber(memory.usage_percent)
            ? ` (${memory.usage_percent.toFixed(1)}%)`
            : '';
        return `${used} / ${total}${percentText}`;
    }

    function resetHostInfoFields() {
        const fields = [
            hostSystemHostname,
            hostSystemUser,
            hostKernel,
            hostCpuModel,
            hostCpuCount,
            hostCpuFrequency,
            hostMemoryTotal,
            hostMemoryUsage,
            hostMemoryAvailable,
            hostInfoUpdated,
            hostLoad,
        ];
        fields.forEach((field) => {
            if (field) {
                field.textContent = '—';
            }
        });
    }

    function resetHostInfoMessage() {
        if (!hostInfoMessage) {
            return;
        }
        while (hostInfoMessage.firstChild) {
            hostInfoMessage.removeChild(hostInfoMessage.firstChild);
        }
        hostInfoMessage.className = 'notice';
        hostInfoMessage.style.display = 'none';
    }

    function setHostInfoBadge(text) {
        if (hostInfoTimestamp) {
            hostInfoTimestamp.textContent = text;
        }
    }

    function showHostInfoPlaceholder(message, badgeText = 'Idle') {
        if (!hostInfoPlaceholder || !hostInfoSection) {
            return;
        }
        clearHostInfoTimer();
        resetHostInfoFields();
        hostInfoPlaceholder.textContent = message;
        hostInfoPlaceholder.style.display = '';
        hostInfoSection.style.display = 'none';
        resetHostInfoMessage();
        setHostInfoBadge(badgeText);
    }

    function setHostInfoLoading(agent) {
        if (!hostInfoPlaceholder || !hostInfoSection) {
            return;
        }
        clearHostInfoTimer();
        resetHostInfoFields();
        hostInfoPlaceholder.textContent = `Collecting host diagnostics from ${agent.name}…`;
        hostInfoPlaceholder.style.display = '';
        hostInfoSection.style.display = 'none';
        resetHostInfoMessage();
        setHostInfoBadge('Loading…');
    }

    function showHostInfoError(message, options = {}) {
        if (!hostInfoSection || !hostInfoPlaceholder) {
            return;
        }
        clearHostInfoTimer();
        resetHostInfoFields();
        hostInfoSection.style.display = '';
        hostInfoPlaceholder.style.display = 'none';
        if (hostInfoMessage) {
            resetHostInfoMessage();
            hostInfoMessage.className = 'notice danger';
            const paragraph = document.createElement('p');
            paragraph.textContent = message;
            hostInfoMessage.appendChild(paragraph);

            const { actionLabel, actionDescription, actionVariant, onAction } = options || {};
            if (actionLabel && typeof onAction === 'function') {
                const actions = document.createElement('div');
                actions.style.marginTop = '0.75rem';
                const button = document.createElement('button');
                button.type = 'button';
                let classes = 'button small';
                if (actionVariant) {
                    classes += ` ${actionVariant}`;
                } else {
                    classes += ' secondary';
                }
                button.className = classes;
                button.textContent = actionLabel;
                button.addEventListener('click', () => {
                    if (button.hasAttribute('disabled')) {
                        return;
                    }
                    const result = onAction();
                    if (result && typeof result.finally === 'function') {
                        button.setAttribute('disabled', 'true');
                        result.finally(() => {
                            button.removeAttribute('disabled');
                        });
                    }
                });
                actions.appendChild(button);

                if (actionDescription) {
                    const helper = document.createElement('p');
                    helper.className = 'muted';
                    helper.style.marginTop = '0.5rem';
                    helper.textContent = actionDescription;
                    actions.appendChild(helper);
                }

                hostInfoMessage.appendChild(actions);
            }

            hostInfoMessage.style.display = '';
        }
        setHostInfoBadge('Error');
        if (hostInfoUpdated) {
            hostInfoUpdated.textContent = '—';
        }
    }

    function renderHostInfo(payload) {
        if (!hostInfoSection || !hostInfoPlaceholder) {
            return;
        }
        resetHostInfoFields();
        hostInfoPlaceholder.style.display = 'none';
        hostInfoSection.style.display = '';

        if (hostInfoMessage) {
            resetHostInfoMessage();
            if (Array.isArray(payload.warnings) && payload.warnings.length) {
                hostInfoMessage.className = 'notice warning';
                const warning = document.createElement('p');
                warning.textContent = payload.warnings.join(' ');
                hostInfoMessage.appendChild(warning);
                hostInfoMessage.style.display = '';
            }
        }

        const system = payload.system || {};
        if (hostSystemHostname) {
            hostSystemHostname.textContent = system.hostname || '—';
        }
        if (hostSystemUser) {
            hostSystemUser.textContent = system.username || '—';
        }
        if (hostKernel) {
            hostKernel.textContent = system.kernel || 'Unavailable';
        }

        const nodeinfo = payload.nodeinfo || {};
        if (hostCpuModel) {
            hostCpuModel.textContent = nodeinfo['CPU model'] || '—';
        }
        if (hostCpuCount) {
            hostCpuCount.textContent = nodeinfo['CPU(s)'] || '—';
        }
        if (hostCpuFrequency) {
            hostCpuFrequency.textContent = nodeinfo['CPU frequency'] || '—';
        }
        if (hostMemoryTotal) {
            hostMemoryTotal.textContent = formatNodeinfoMemory(nodeinfo['Memory size']);
        }

        const performance = payload.performance || {};
        if (hostLoad) {
            hostLoad.textContent = formatLoadAverage(performance.load_average);
        }
        const memory = performance.memory || null;
        if (hostMemoryUsage) {
            hostMemoryUsage.textContent = formatMemoryUsage(memory);
        }
        if (hostMemoryAvailable) {
            hostMemoryAvailable.textContent = memory && isFiniteNumber(memory.available_bytes)
                ? humanizeBytes(memory.available_bytes)
                : 'Unavailable';
        }

        if (hostInfoUpdated) {
            hostInfoUpdated.textContent = payload.collected_at
                ? new Date(payload.collected_at).toLocaleString()
                : '—';
        }
        if (hostInfoTimestamp) {
            hostInfoTimestamp.textContent = payload.collected_at
                ? `Updated ${new Date(payload.collected_at).toLocaleTimeString()}`
                : 'Updated just now';
        }
    }

    function scheduleHostInfoRefresh(agent) {
        clearHostInfoTimer();
        if (!agent || !state.endpoints.host_info) {
            return;
        }
        hostInfoTimer = window.setTimeout(() => {
            if (!state.selectedAgent || state.selectedAgent.id !== agent.id) {
                return;
            }
            fetchHostInfo(agent, { showLoading: false });
        }, 15000);
    }

    async function allowUnknownHostKeys(agentId) {
        if (!state.endpoints.allow_unknown_hosts) {
            return false;
        }
        const agent = state.agents.find((item) => item.id === agentId);
        if (!agent) {
            return false;
        }
        if (agent.allow_unknown_hosts) {
            return true;
        }
        if (!state.selectedAgent || state.selectedAgent.id !== agentId) {
            return false;
        }

        setHostInfoLoading(agent);

        try {
            const url = buildUrl(state.endpoints.allow_unknown_hosts, agentId);
            const response = await fetch(url, {
                method: 'POST',
                credentials: 'same-origin',
            });
            const payload = await response.json();
            if (!response.ok || payload.status !== 'ok' || !payload.agent) {
                throw new Error(payload.message || 'Failed to update hypervisor settings.');
            }

            const updatedAgent = payload.agent;
            state.agents = state.agents.map((item) => (
                item.id === updatedAgent.id ? updatedAgent : item
            ));
            state.selectedAgent = updatedAgent;
            renderAgents();
            updateAgentLabel(updatedAgent);
            updateSshSection(updatedAgent);

            await fetchVms(updatedAgent);
            await fetchHostInfo(updatedAgent, { showLoading: true });
            return true;
        } catch (error) {
            const message = (error && error.message) || 'Failed to update hypervisor settings.';
            showHostInfoError(message, {
                actionLabel: 'Allow unknown host keys',
                actionDescription: 'Trust this hypervisor and retry the connection.',
                onAction: () => allowUnknownHostKeys(agentId),
            });
            return false;
        }
    }

    async function fetchHostInfo(agent, options = {}) {
        const { showLoading = true } = options;

        if (!hostInfoSection || !hostInfoPlaceholder) {
            return;
        }

        if (!agent) {
            const message = state.agents.length
                ? 'Select a hypervisor to view system metrics.'
                : 'Pair a hypervisor with the agent service to monitor its performance metrics.';
            showHostInfoPlaceholder(message, 'Idle');
            return;
        }

        if (!state.endpoints.host_info) {
            showHostInfoError('Host diagnostics endpoint is not available.');
            return;
        }

        if (showLoading) {
            setHostInfoLoading(agent);
        }

        try {
            clearHostInfoTimer();
            const url = buildUrl(state.endpoints.host_info, agent.id);
            const response = await fetch(url, {
                credentials: 'same-origin',
                cache: 'no-store',
            });
            const payload = await response.json();
            if (!response.ok || payload.status !== 'ok') {
                const error = new Error(payload.message || 'Unable to retrieve host diagnostics.');
                error.details = payload;
                error.status = response.status;
                throw error;
            }
            if (!state.selectedAgent || state.selectedAgent.id !== agent.id) {
                return;
            }
            renderHostInfo(payload);
            scheduleHostInfoRefresh(agent);
        } catch (error) {
            const message = (error && error.message) || 'Unable to retrieve host diagnostics.';
            let options;
            if (
                agent &&
                !agent.allow_unknown_hosts &&
                state.endpoints.allow_unknown_hosts &&
                error &&
                error.details &&
                error.details.code === 'host_key_verification_failed'
            ) {
                options = {
                    actionLabel: 'Allow unknown host keys',
                    actionDescription: 'Trust this hypervisor and retry the connection.',
                    onAction: () => allowUnknownHostKeys(agent.id),
                };
            }
            showHostInfoError(message, options);
        }
    }

    function renderAgents() {
        if (!agentList) {
            return;
        }
        agentList.innerHTML = '';
        if (!state.agents.length) {
            const empty = document.createElement('p');
            empty.className = 'muted';
            empty.textContent = 'No hypervisors are paired yet. Install and start the PlayrServers agent on a host to enrol it automatically.';
            agentList.appendChild(empty);
            return;
        }
        state.agents.forEach((agent) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'agent-entry';
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'agent-tile' + (state.selectedAgent && state.selectedAgent.id === agent.id ? ' active' : '');
            button.dataset.agentId = String(agent.id);
            button.innerHTML = `<strong>${agent.name}</strong>
                <div class="agent-meta">
                    <span>${agent.hostname}:${agent.port}</span>
                    <span>SSH · ${agent.username}</span>
                </div>`;
            button.addEventListener('click', () => {
                selectAgent(agent);
            });
            wrapper.appendChild(button);

            const actions = document.createElement('div');
            actions.className = 'agent-actions';
            const created = document.createElement('span');
            created.className = 'muted';
            try {
                created.textContent = `Created ${new Date(agent.created_at).toLocaleString()}`;
            } catch (_) {
                created.textContent = 'Created recently';
            }
            actions.appendChild(created);

            const form = document.createElement('form');
            form.method = 'post';
            form.action = agent.remove_url;
            form.innerHTML = '<button type="submit" class="text-button">Remove</button>';
            form.addEventListener('submit', (event) => {
                if (!confirm(`Remove ${agent.name}?`)) {
                    event.preventDefault();
                }
            });
            actions.appendChild(form);
            wrapper.appendChild(actions);

            agentList.appendChild(wrapper);
        });
    }

    function updateSshSection(agent) {
        if (!sshCommand || !sshSection || !sshPlaceholder) {
            return;
        }
        if (!agent) {
            sshSection.style.display = 'none';
            sshPlaceholder.style.display = '';
            sshCommand.textContent = '';
            disconnectTerminal(false);
            showTerminalOverlay('Select a hypervisor and click Connect to start a session.');
            setTerminalStatus('Disconnected.');
            if (sshConnectButton) {
                sshConnectButton.setAttribute('disabled', 'true');
            }
            if (sshDisconnectButton) {
                sshDisconnectButton.setAttribute('disabled', 'true');
            }
            if (sshCopyButton) {
                if (sshCopyButtonLabel) {
                    sshCopyButton.textContent = sshCopyButtonLabel;
                }
                sshCopyButton.setAttribute('disabled', 'true');
            }
            return;
        }

        const command = agent.port === 22
            ? `ssh ${agent.username}@${agent.hostname}`
            : `ssh -p ${agent.port} ${agent.username}@${agent.hostname}`;
        sshCommand.textContent = command;
        sshSection.style.display = '';
        sshPlaceholder.style.display = 'none';

        const connectedToAgent = Boolean(
            terminalSocket && terminalSocket.readyState === WebSocket.OPEN && terminalAgentId === agent.id,
        );

        if (terminalAgentId !== null && terminalAgentId !== agent.id) {
            disconnectTerminal(false);
        }

        if (connectedToAgent) {
            hideTerminalOverlay();
            setTerminalStatus(`Connected to ${agent.hostname}`);
            if (sshConnectButton) {
                sshConnectButton.setAttribute('disabled', 'true');
            }
            if (sshDisconnectButton) {
                sshDisconnectButton.removeAttribute('disabled');
            }
        } else {
            showTerminalOverlay(`Click Connect to open a session with ${agent.name}.`);
            setTerminalStatus('Ready to connect.');
            if (sshConnectButton) {
                sshConnectButton.removeAttribute('disabled');
            }
            if (sshDisconnectButton) {
                sshDisconnectButton.setAttribute('disabled', 'true');
            }
            clearTerminal();
            ensureTerminal();
            if (fitAddon) {
                requestAnimationFrame(() => {
                    fitAddon.fit();
                    sendTerminalResize();
                });
            }
        }

        if (sshCopyButton) {
            sshCopyButton.removeAttribute('disabled');
            if (sshCopyButtonLabel) {
                sshCopyButton.textContent = sshCopyButtonLabel;
            }
        }
    }

    function updateAgentLabel(agent) {
        if (agentLabel) {
            agentLabel.textContent = agent ? agent.name : 'No agent selected';
        }
    }

    function setVmStatus(message, isError = false) {
        if (!vmStatus) {
            return;
        }
        vmStatus.textContent = message;
        vmStatus.classList.toggle('danger', isError);
    }

    function renderVmTable() {
        if (!vmTableBody || !vmTableWrapper) {
            return;
        }

        const vms = Array.isArray(state.vms) ? state.vms : [];
        vmTableBody.innerHTML = '';

        if (!vms.length) {
            vmTableWrapper.style.display = 'none';
            setVmStatus('No virtual machines reported by the selected hypervisor.');
            state.selectedVm = null;
            updateVmConsoleSection();
            return;
        }

        vmTableWrapper.style.display = '';
        const selectedVmName = state.selectedVm ? state.selectedVm.name : null;
        let selectedVmStillPresent = false;

        vms.forEach((vm) => {
            const row = document.createElement('tr');
            row.className = 'vm-row';
            row.dataset.vmName = vm.name;

            row.addEventListener('click', (event) => {
                if (event.target && event.target.closest('button')) {
                    return;
                }
                selectVm(vm);
            });

            if (selectedVmName && vm.name === selectedVmName) {
                row.classList.add('selected');
                selectedVmStillPresent = true;
            }

            const nameCell = document.createElement('td');
            nameCell.textContent = vm.name;
            row.appendChild(nameCell);

            const stateCell = document.createElement('td');
            const normalizedState = (vm.state || '').toLowerCase();
            const dot = document.createElement('span');
            let stateClass = 'status-other';
            if (normalizedState.includes('running')) {
                stateClass = 'status-running';
            } else if (normalizedState.includes('shut') || normalizedState.includes('off')) {
                stateClass = 'status-shutoff';
            } else if (normalizedState.includes('pause')) {
                stateClass = 'status-paused';
            }
            dot.className = 'status-dot ' + stateClass;
            const label = document.createElement('span');
            label.appendChild(dot);
            label.append(vm.state);
            stateCell.appendChild(label);
            row.appendChild(stateCell);

            const actionsCell = document.createElement('td');
            actionsCell.className = 'vm-actions';

        const makeActionButton = (label, action, variant, options = {}) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'button small' + (variant ? ' ' + variant : '');
            button.textContent = label;
            button.addEventListener('click', (event) => {
                event.stopPropagation();
                if (options.confirmMessage) {
                    const confirmed = window.confirm(options.confirmMessage);
                    if (!confirmed) {
                        return;
                    }
                }
                triggerVmAction(vm.name, action);
            });
            return button;
        };

        actionsCell.appendChild(makeActionButton('Start', 'start'));
        actionsCell.appendChild(makeActionButton('Shutdown', 'shutdown'));
        actionsCell.appendChild(makeActionButton('Force stop', 'force-stop', 'danger'));
        actionsCell.appendChild(makeActionButton('Reboot', 'reboot'));
        actionsCell.appendChild(
            makeActionButton('Destroy', 'destroy', 'danger', {
                confirmMessage: `Destroy ${vm.name}? This removes the virtual machine definition and associated storage.`,
            }),
        );

        const consoleButton = document.createElement('button');
            consoleButton.type = 'button';
            consoleButton.className = 'button small secondary';
            consoleButton.textContent = 'Console';
            consoleButton.addEventListener('click', (event) => {
                event.stopPropagation();
                selectVm(vm);
                connectVmConsole();
            });
            actionsCell.appendChild(consoleButton);

            row.appendChild(actionsCell);
            vmTableBody.appendChild(row);
        });

        if (selectedVmName && !selectedVmStillPresent) {
            state.selectedVm = null;
            updateVmConsoleSection();
        }
    }

    async function fetchVms(agent) {
        if (!agent) {
            state.vms = [];
            state.selectedVm = null;
            renderVmTable();
            updateVmConsoleSection();
            setVmStatus('Select a hypervisor to load its virtual machines.');
            return;
        }
        setVmStatus('Querying virtual machines from ' + agent.name + '…');
        try {
            const url = buildUrl(state.endpoints.list_vms, agent.id);
            const response = await fetch(url, {
                credentials: 'same-origin',
                cache: 'no-store',
            });
            const payload = await response.json();
            if (payload.status !== 'ok') {
                throw new Error(payload.message || 'Unable to list virtual machines.');
            }
            state.vms = Array.isArray(payload.vms) ? payload.vms : [];
            renderVmTable();
            updateVmConsoleSection();
            if (state.vms.length) {
                setVmStatus(`${state.vms.length} virtual machine(s) reported by ${agent.name}.`);
            }
        } catch (error) {
            state.vms = [];
            state.selectedVm = null;
            renderVmTable();
            updateVmConsoleSection();
            setVmStatus(error.message || 'Failed to query virtual machines.', true);
        }
    }

    async function triggerVmAction(vmName, action) {
        const agent = state.selectedAgent;
        if (!agent) {
            return;
        }
        setVmStatus(`Dispatching ${action} for ${vmName}…`);
        try {
            const url = buildUrl(state.endpoints.vm_action, agent.id, vmName, action);
            const response = await fetch(url, {
                method: 'POST',
                credentials: 'same-origin',
            });
            const payload = await response.json();
            if (payload.status !== 'ok') {
                throw new Error(payload.message || 'Operation failed.');
            }
            setVmStatus(payload.message || `Dispatched ${action} for ${vmName}.`);
            await fetchVms(agent);
        } catch (error) {
            setVmStatus(error.message || 'Operation failed.', true);
        }
    }

    function selectAgent(agent) {
        state.selectedAgent = agent;
        state.selectedVm = null;
        state.vms = [];
        disconnectVmConsole(false);
        renderAgents();
        updateAgentLabel(agent);
        updateSshSection(agent);
        updateDeploymentSection(agent);
        renderVmTable();
        updateVmConsoleSection();
        fetchVms(agent);
        fetchHostInfo(agent);
    }

    renderAgents();
    updateAgentLabel(state.selectedAgent);
    updateSshSection(state.selectedAgent);
    updateDeploymentSection(state.selectedAgent);
    renderVmTable();
    updateVmConsoleSection();
    if (state.selectedAgent) {
        fetchVms(state.selectedAgent);
        fetchHostInfo(state.selectedAgent);
    } else if (state.agents.length) {
        setVmStatus('Select a hypervisor to load its virtual machines.');
        showHostInfoPlaceholder('Select a hypervisor to view system metrics.');
    } else {
        setVmStatus('Pair a hypervisor with the agent service to view its virtual machines.');
        showHostInfoPlaceholder('Pair a hypervisor with the agent service to monitor its performance metrics.');
    }

    refreshDeploymentSummaries({ manual: true });
})();
</script>
{% endblock %}
