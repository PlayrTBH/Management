{% extends "layout.html" %}
{% block extra_head %}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
{% endblock %}
{% block title %}Management · PlayrServers Control Plane{% endblock %}
{% block content %}
<div class="stack">
    <div class="card">
        <h1>Hypervisor fleet management</h1>
        <p class="muted">Register remote virtualization hosts, audit their metadata, and keep SSH credentials synchronized with the automation API.</p>
        {% if messages %}
            {% for item in messages %}
                {% set category = item.category if item.category is defined else 'info' %}
                <div class="notice{% if category == 'error' %} danger{% elif category == 'success' %} success{% endif %}">{{ item.message }}</div>
            {% endfor %}
        {% endif %}
        <div class="management-grid">
            <section>
                <h2>Registered hypervisors</h2>
                <div class="agent-list" id="agent-list">
                    {% if agents %}
                        {% for agent in agents %}
                            <div class="agent-entry" data-agent-id="{{ agent.id }}">
                                <button type="button" class="agent-tile{% if selected_agent and agent.id == selected_agent.id %} active{% endif %}" data-agent='{{ agent | tojson }}'>
                                    <strong>{{ agent.name }}</strong>
                                    <div class="agent-meta">
                                        <span>{{ agent.hostname }}:{{ agent.port }}</span>
                                        <span>SSH · {{ agent.username }}</span>
                                    </div>
                                </button>
                                <div class="agent-actions">
                                    <span class="muted">Created {{ agent.created_at }}</span>
                                    <form method="post" action="{{ agent.remove_url }}" onsubmit="return confirm('Remove {{ agent.name }}?');">
                                        <button type="submit" class="text-button">Remove</button>
                                    </form>
                                </div>
                            </div>
                        {% endfor %}
                    {% else %}
                        <p class="muted">No hypervisors registered yet. Use the form to onboard your first agent.</p>
                    {% endif %}
                </div>
            </section>
            <section>
                <h2>Add hypervisor</h2>
                <form method="post" action="{{ request.url_for('register_agent') }}">
                    <div class="field">
                        <label for="agent-name">Name</label>
                        <input type="text" id="agent-name" name="name" required placeholder="hypervisor-01">
                    </div>
                    <div class="field">
                        <label for="agent-hostname">Hostname / IP</label>
                        <input type="text" id="agent-hostname" name="hostname" required placeholder="203.0.113.42">
                    </div>
                    <div class="field">
                        <label for="agent-port">SSH port</label>
                        <input type="number" id="agent-port" name="port" value="22" min="1" max="65535" required>
                    </div>
                    <div class="field">
                        <label for="agent-username">SSH username</label>
                        <input type="text" id="agent-username" name="username" required placeholder="qemu-admin">
                    </div>
                    <div class="field">
                        <label for="agent-key">Private key</label>
                        <textarea id="agent-key" name="private_key" required placeholder="-----BEGIN OPENSSH PRIVATE KEY-----"></textarea>
                    </div>
                    <div class="field">
                        <label for="agent-passphrase">Private key passphrase <span class="muted">(optional)</span></label>
                        <input type="password" id="agent-passphrase" name="private_key_passphrase" autocomplete="off">
                    </div>
                    <div class="field">
                        <label for="agent-known-hosts">Known hosts path <span class="muted">(optional)</span></label>
                        <input type="text" id="agent-known-hosts" name="known_hosts_path" placeholder="~/.ssh/known_hosts">
                    </div>
                    <div class="field" style="flex-direction: row; align-items: center; gap: 0.75rem;">
                        <input type="checkbox" id="agent-allow-unknown" name="allow_unknown_hosts" value="1">
                        <label for="agent-allow-unknown">Allow unknown host keys</label>
                    </div>
                    <p class="help-text">Upload a dedicated automation key. The control plane stores the private key encrypted at rest.</p>
                    <button type="submit" class="button">Register hypervisor</button>
                </form>
            </section>
        </div>
    </div>

    <div class="card">
        <div class="section-header">
            <h2>Virtual machine inventory</h2>
            <span class="badge" id="selected-agent-label">{% if selected_agent %}{{ selected_agent.name }}{% else %}No agent selected{% endif %}</span>
        </div>
        <div id="vm-status" class="muted">
            {% if not agents %}
                Register a hypervisor to view its virtual machines.
            {% elif not selected_agent %}
                Select a hypervisor to load its virtual machines.
            {% else %}
                Loading virtual machines…
            {% endif %}
        </div>
        <div class="table-wrapper" id="vm-table-wrapper"{% if not selected_agent %} style="display: none;"{% endif %}>
            <table id="vm-table">
                <thead>
                    <tr>
                        <th scope="col">Name</th>
                        <th scope="col">State</th>
                        <th scope="col">Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <div class="card">
        <div class="section-header">
            <h2>Host diagnostics</h2>
            <span class="badge" id="host-info-timestamp">{% if selected_agent %}Awaiting data{% else %}Idle{% endif %}</span>
        </div>
        <div id="host-info-placeholder" class="placeholder-box">
            {% if not agents %}
                Register a hypervisor to monitor its performance metrics.
            {% elif not selected_agent %}
                Select a hypervisor to view system metrics.
            {% else %}
                Collecting host diagnostics…
            {% endif %}
        </div>
        <div id="host-info-section" style="display: none;">
            <div id="host-info-message" class="notice" style="display: none;"></div>
            <div class="host-info-grid">
                <div>
                    <h3>System facts</h3>
                    <dl class="stat-list">
                        <div><dt>Hostname</dt><dd id="host-system-hostname">—</dd></div>
                        <div><dt>Kernel</dt><dd id="host-kernel">—</dd></div>
                        <div><dt>SSH user</dt><dd id="host-system-user">—</dd></div>
                        <div><dt>CPU model</dt><dd id="host-cpu-model">—</dd></div>
                        <div><dt>CPU(s)</dt><dd id="host-cpu-count">—</dd></div>
                        <div><dt>CPU frequency</dt><dd id="host-cpu-frequency">—</dd></div>
                        <div><dt>Memory</dt><dd id="host-memory-total">—</dd></div>
                    </dl>
                </div>
                <div>
                    <h3>Performance</h3>
                    <dl class="stat-list">
                        <div><dt>Load avg (1/5/15m)</dt><dd id="host-load">—</dd></div>
                        <div><dt>Memory usage</dt><dd id="host-memory-usage">—</dd></div>
                        <div><dt>Memory available</dt><dd id="host-memory-available">—</dd></div>
                        <div><dt>Collected</dt><dd id="host-info-updated">—</dd></div>
                    </dl>
                </div>
            </div>
        </div>
    </div>

    <div class="card">
        <div class="section-header">
            <h2>Direct SSH console</h2>
            <span class="badge warning">Operator access</span>
        </div>
        <div id="ssh-placeholder" class="placeholder-box"{% if selected_agent %} style="display: none;"{% endif %}>
            Select a hypervisor to populate SSH connection details.
        </div>
        <div id="ssh-section"{% if not selected_agent %} style="display: none;"{% endif %}>
            <p class="muted">Use the in-browser console to connect to the selected hypervisor or copy the ready-to-run SSH command.</p>
            <div class="ssh-terminal-wrapper">
                <div id="ssh-terminal" class="ssh-terminal"></div>
                <div id="ssh-terminal-overlay" class="ssh-terminal-overlay">Select a hypervisor and click Connect to start a session.</div>
            </div>
            <div class="ssh-controls">
                <div class="ssh-buttons">
                    <button type="button" id="ssh-connect" class="button secondary">Connect</button>
                    <button type="button" id="ssh-disconnect" class="button secondary" disabled>Disconnect</button>
                    <button type="button" id="ssh-copy-command" class="button secondary">Copy SSH command</button>
                </div>
                <span id="ssh-terminal-status" class="ssh-status">Disconnected.</span>
            </div>
            <code id="ssh-command"></code>
            <p class="help-text">Sessions authenticate using the stored automation key and run entirely within your browser.</p>
        </div>
    </div>

    <div class="card">
        <h2>Remote agent deployment</h2>
        <div class="placeholder-box">
            <p>Guidance on locating and installing the PlayrServers remote agent will appear here. Include package repository locations, service management commands, and upgrade advice once distribution details are finalized.</p>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
<script id="agent-data" type="application/json">{{ agents | tojson }}</script>
<script id="selected-agent" type="application/json">{{ selected_agent | tojson if selected_agent else 'null' }}</script>
<script id="management-endpoints" type="application/json">{{ endpoints | tojson }}</script>
<script>
(() => {
    const agentDataElement = document.getElementById('agent-data');
    const selectedAgentElement = document.getElementById('selected-agent');
    const endpointsElement = document.getElementById('management-endpoints');

    if (!agentDataElement || !selectedAgentElement || !endpointsElement) {
        return;
    }

    const state = {
        agents: JSON.parse(agentDataElement.textContent || '[]'),
        selectedAgent: JSON.parse(selectedAgentElement.textContent || 'null'),
        endpoints: JSON.parse(endpointsElement.textContent || '{}'),
    };

    if (!state.endpoints || !state.endpoints.list_vms) {
        return;
    }

    const agentList = document.getElementById('agent-list');
    const vmStatus = document.getElementById('vm-status');
    const vmTableWrapper = document.getElementById('vm-table-wrapper');
    const vmTableBody = document.querySelector('#vm-table tbody');
    const agentLabel = document.getElementById('selected-agent-label');
    const sshCommand = document.getElementById('ssh-command');
    const sshSection = document.getElementById('ssh-section');
    const sshPlaceholder = document.getElementById('ssh-placeholder');
    const sshTerminalContainer = document.getElementById('ssh-terminal');
    const sshTerminalOverlay = document.getElementById('ssh-terminal-overlay');
    const sshConnectButton = document.getElementById('ssh-connect');
    const sshDisconnectButton = document.getElementById('ssh-disconnect');
    const sshCopyButton = document.getElementById('ssh-copy-command');
    const sshStatus = document.getElementById('ssh-terminal-status');
    const hostInfoPlaceholder = document.getElementById('host-info-placeholder');
    const hostInfoSection = document.getElementById('host-info-section');
    const hostInfoMessage = document.getElementById('host-info-message');
    const hostInfoTimestamp = document.getElementById('host-info-timestamp');
    const hostSystemHostname = document.getElementById('host-system-hostname');
    const hostSystemUser = document.getElementById('host-system-user');
    const hostKernel = document.getElementById('host-kernel');
    const hostCpuModel = document.getElementById('host-cpu-model');
    const hostCpuCount = document.getElementById('host-cpu-count');
    const hostCpuFrequency = document.getElementById('host-cpu-frequency');
    const hostMemoryTotal = document.getElementById('host-memory-total');
    const hostMemoryUsage = document.getElementById('host-memory-usage');
    const hostMemoryAvailable = document.getElementById('host-memory-available');
    const hostInfoUpdated = document.getElementById('host-info-updated');
    const hostLoad = document.getElementById('host-load');

    let hostInfoTimer = null;
    let terminal = null;
    let fitAddon = null;
    let terminalSocket = null;
    let terminalAgentId = null;
    let closingTerminalState = null;
    const textEncoder = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;
    const textDecoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;
    const sshCopyButtonLabel = sshCopyButton ? sshCopyButton.textContent : '';

    function buildUrl(template, agentId, vmName, action) {
        let url = template.replace('/0/', '/' + agentId + '/');
        if (vmName !== undefined) {
            url = url.replace('__VM__', encodeURIComponent(vmName));
        }
        if (action !== undefined) {
            url = url.replace('__ACTION__', action);
        }
        return url;
    }

    function buildWebsocketUrl(template, agentId) {
        if (!template) {
            return null;
        }
        const replaced = template.replace('/0/', '/' + agentId + '/');
        try {
            const url = new URL(replaced, window.location.href);
            url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
            return url.toString();
        } catch (_) {
            return null;
        }
    }

    function showTerminalOverlay(message) {
        if (sshTerminalOverlay) {
            sshTerminalOverlay.textContent = message;
            sshTerminalOverlay.style.display = 'flex';
        }
    }

    function hideTerminalOverlay() {
        if (sshTerminalOverlay) {
            sshTerminalOverlay.style.display = 'none';
        }
    }

    function setTerminalStatus(message, isError = false) {
        if (!sshStatus) {
            return;
        }
        sshStatus.textContent = message;
        if (isError) {
            sshStatus.classList.add('error');
        } else {
            sshStatus.classList.remove('error');
        }
    }

    function ensureTerminal() {
        if (terminal || !sshTerminalContainer) {
            return;
        }
        if (typeof window.Terminal !== 'function') {
            showTerminalOverlay('Terminal library failed to load.');
            setTerminalStatus('Browser terminal unavailable.', true);
            return;
        }
        terminal = new window.Terminal({
            convertEol: true,
            cursorBlink: true,
            fontFamily: 'JetBrains Mono, SFMono-Regular, Menlo, Consolas, "Liberation Mono", Courier, monospace',
            fontSize: 14,
            theme: {
                background: '#0f172a',
                foreground: '#f8fafc',
            },
        });
        if (window.FitAddon && typeof window.FitAddon.FitAddon === 'function') {
            fitAddon = new window.FitAddon.FitAddon();
            terminal.loadAddon(fitAddon);
        }
        terminal.open(sshTerminalContainer);
        if (fitAddon) {
            fitAddon.fit();
        }
        terminal.focus();
        terminal.onData((data) => {
            if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
                if (textEncoder) {
                    terminalSocket.send(textEncoder.encode(data));
                } else {
                    terminalSocket.send(data);
                }
            }
        });
    }

    function clearTerminal() {
        if (terminal) {
            terminal.reset();
        }
    }

    function sendTerminalResize() {
        if (!terminal || !terminalSocket || terminalSocket.readyState !== WebSocket.OPEN) {
            return;
        }
        const payload = {
            type: 'resize',
            cols: terminal.cols,
            rows: terminal.rows,
        };
        try {
            terminalSocket.send(JSON.stringify(payload));
        } catch (_) {
            // ignore transmission errors
        }
    }

    function disconnectTerminal(showMessage = true) {
        if (!terminalSocket) {
            if (showMessage) {
                setTerminalStatus('Disconnected.');
                showTerminalOverlay('Session disconnected.');
            }
            if (sshDisconnectButton) {
                sshDisconnectButton.setAttribute('disabled', 'true');
            }
            if (sshConnectButton) {
                if (state.selectedAgent) {
                    sshConnectButton.removeAttribute('disabled');
                } else {
                    sshConnectButton.setAttribute('disabled', 'true');
                }
            }
            if (sshCopyButton) {
                if (sshCopyButtonLabel) {
                    sshCopyButton.textContent = sshCopyButtonLabel;
                }
                if (state.selectedAgent) {
                    sshCopyButton.removeAttribute('disabled');
                } else {
                    sshCopyButton.setAttribute('disabled', 'true');
                }
            }
            terminalAgentId = null;
            return;
        }
        closingTerminalState = showMessage ? 'manual' : 'silent';
        const socket = terminalSocket;
        terminalSocket = null;
        try {
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'close' }));
            }
            socket.close();
        } catch (_) {
            // ignore close failures
        }
    }

    function connectTerminal(agent) {
        if (!agent) {
            return;
        }

        ensureTerminal();
        if (!terminal) {
            setTerminalStatus('Browser terminal unavailable.', true);
            showTerminalOverlay('Unable to initialize terminal component.');
            return;
        }

        if (!state.endpoints || !state.endpoints.ssh_terminal) {
            setTerminalStatus('Terminal endpoint is not configured.', true);
            showTerminalOverlay('Terminal endpoint is not available.');
            return;
        }

        const websocketUrl = buildWebsocketUrl(state.endpoints.ssh_terminal, agent.id);
        if (!websocketUrl) {
            setTerminalStatus('Terminal endpoint is not configured.', true);
            showTerminalOverlay('Terminal endpoint is not available.');
            return;
        }

        if (terminalSocket) {
            if (terminalAgentId === agent.id && terminalSocket.readyState === WebSocket.OPEN) {
                return;
            }
            disconnectTerminal(false);
        }

        closingTerminalState = null;
        terminalAgentId = agent.id;
        setTerminalStatus(`Connecting to ${agent.hostname}…`);
        showTerminalOverlay(`Connecting to ${agent.hostname}…`);

        if (sshConnectButton) {
            sshConnectButton.setAttribute('disabled', 'true');
        }
        if (sshDisconnectButton) {
            sshDisconnectButton.removeAttribute('disabled');
        }
        if (sshCopyButton) {
            sshCopyButton.removeAttribute('disabled');
        }

        clearTerminal();

        try {
            terminalSocket = new WebSocket(websocketUrl);
        } catch (_) {
            terminalSocket = null;
            setTerminalStatus('Failed to connect.', true);
            showTerminalOverlay('Failed to establish SSH session.');
            if (sshConnectButton) {
                sshConnectButton.removeAttribute('disabled');
            }
            if (sshDisconnectButton) {
                sshDisconnectButton.setAttribute('disabled', 'true');
            }
            return;
        }

        terminalSocket.binaryType = 'arraybuffer';

        terminalSocket.addEventListener('open', () => {
            setTerminalStatus(`Connected to ${agent.hostname}`);
            hideTerminalOverlay();
            if (fitAddon) {
                fitAddon.fit();
            }
            sendTerminalResize();
        });

        terminalSocket.addEventListener('message', (event) => {
            if (typeof event.data === 'string') {
                try {
                    const payload = JSON.parse(event.data);
                    if (payload.type === 'status' && payload.status === 'connected') {
                        hideTerminalOverlay();
                        return;
                    }
                    if (payload.type === 'error') {
                        setTerminalStatus(payload.message || 'SSH session error.', true);
                        showTerminalOverlay(payload.message || 'SSH session error.');
                    }
                } catch (_) {
                    // ignore non-JSON control messages
                }
                return;
            }

            if (event.data instanceof ArrayBuffer && terminal) {
                let text = '';
                if (textDecoder) {
                    text = textDecoder.decode(event.data);
                } else {
                    const view = new Uint8Array(event.data);
                    text = Array.from(view).map((code) => String.fromCharCode(code)).join('');
                }
                terminal.write(text);
            }
        });

        terminalSocket.addEventListener('close', () => {
            const mode = closingTerminalState;
            closingTerminalState = null;
            terminalSocket = null;
            terminalAgentId = null;
            if (sshDisconnectButton) {
                sshDisconnectButton.setAttribute('disabled', 'true');
            }
            if (sshConnectButton) {
                if (state.selectedAgent) {
                    sshConnectButton.removeAttribute('disabled');
                } else {
                    sshConnectButton.setAttribute('disabled', 'true');
                }
            }
            if (sshCopyButton) {
                if (sshCopyButtonLabel) {
                    sshCopyButton.textContent = sshCopyButtonLabel;
                }
                if (state.selectedAgent) {
                    sshCopyButton.removeAttribute('disabled');
                } else {
                    sshCopyButton.setAttribute('disabled', 'true');
                }
            }
            if (mode !== 'silent') {
                setTerminalStatus('Disconnected.');
                showTerminalOverlay('Session disconnected.');
            }
        });

        terminalSocket.addEventListener('error', () => {
            setTerminalStatus('Failed to connect.', true);
            showTerminalOverlay('Failed to establish SSH session.');
        });
    }

    if (sshConnectButton) {
        sshConnectButton.addEventListener('click', () => {
            if (state.selectedAgent) {
                connectTerminal(state.selectedAgent);
            }
        });
    }

    if (sshDisconnectButton) {
        sshDisconnectButton.addEventListener('click', () => {
            disconnectTerminal();
        });
    }

    if (sshCopyButton) {
        sshCopyButton.addEventListener('click', async () => {
            if (!sshCommand) {
                return;
            }
            const text = (sshCommand.textContent || '').trim();
            if (!text) {
                return;
            }

            const restoreLabel = () => {
                if (sshCopyButtonLabel) {
                    sshCopyButton.textContent = sshCopyButtonLabel;
                }
            };

            const indicateCopied = () => {
                sshCopyButton.textContent = 'Copied!';
                window.setTimeout(() => {
                    restoreLabel();
                }, 1500);
            };

            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    indicateCopied();
                    return;
                }
            } catch (_) {
                // Fallback to execCommand below
            }

            try {
                const helper = document.createElement('textarea');
                helper.value = text;
                helper.style.position = 'fixed';
                helper.style.opacity = '0';
                helper.style.pointerEvents = 'none';
                document.body.appendChild(helper);
                helper.focus();
                helper.select();
                const successful = document.execCommand('copy');
                document.body.removeChild(helper);
                if (successful) {
                    indicateCopied();
                    return;
                }
            } catch (_) {
                // ignore failures and fall through to status update
            }

            setTerminalStatus('Unable to copy command.', true);
            window.setTimeout(() => {
                restoreLabel();
            }, 1500);
        });
    }

    window.addEventListener('resize', () => {
        if (fitAddon) {
            fitAddon.fit();
            sendTerminalResize();
        }
    });

    window.addEventListener('beforeunload', () => {
        disconnectTerminal(false);
    });

    function clearHostInfoTimer() {
        if (hostInfoTimer !== null) {
            clearTimeout(hostInfoTimer);
            hostInfoTimer = null;
        }
    }

    function isFiniteNumber(value) {
        return typeof value === 'number' && Number.isFinite(value);
    }

    function humanizeBytes(bytes) {
        if (!isFiniteNumber(bytes)) {
            return 'Unavailable';
        }
        const units = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'];
        let index = 0;
        let value = bytes;
        while (value >= 1024 && index < units.length - 1) {
            value /= 1024;
            index += 1;
        }
        const precision = value >= 10 || index === 0 ? 0 : 1;
        return `${value.toFixed(precision)} ${units[index]}`;
    }

    function parseNodeinfoMemory(value) {
        if (typeof value !== 'string') {
            return null;
        }
        const match = value.match(/([0-9.]+)\s*KiB/i);
        if (!match) {
            return null;
        }
        const parsed = parseFloat(match[1]);
        if (!Number.isFinite(parsed)) {
            return null;
        }
        return parsed * 1024;
    }

    function formatNodeinfoMemory(value) {
        const bytes = parseNodeinfoMemory(value);
        if (bytes === null) {
            return value || 'Unavailable';
        }
        return humanizeBytes(bytes);
    }

    function formatLoadAverage(load) {
        if (!load || !isFiniteNumber(load.one) || !isFiniteNumber(load.five) || !isFiniteNumber(load.fifteen)) {
            return 'Unavailable';
        }
        return `${load.one.toFixed(2)} / ${load.five.toFixed(2)} / ${load.fifteen.toFixed(2)}`;
    }

    function formatMemoryUsage(memory) {
        if (!memory || !isFiniteNumber(memory.total_bytes) || !isFiniteNumber(memory.used_bytes)) {
            return 'Unavailable';
        }
        const used = humanizeBytes(memory.used_bytes);
        const total = humanizeBytes(memory.total_bytes);
        const percentText = isFiniteNumber(memory.usage_percent)
            ? ` (${memory.usage_percent.toFixed(1)}%)`
            : '';
        return `${used} / ${total}${percentText}`;
    }

    function resetHostInfoFields() {
        const fields = [
            hostSystemHostname,
            hostSystemUser,
            hostKernel,
            hostCpuModel,
            hostCpuCount,
            hostCpuFrequency,
            hostMemoryTotal,
            hostMemoryUsage,
            hostMemoryAvailable,
            hostInfoUpdated,
            hostLoad,
        ];
        fields.forEach((field) => {
            if (field) {
                field.textContent = '—';
            }
        });
    }

    function setHostInfoBadge(text) {
        if (hostInfoTimestamp) {
            hostInfoTimestamp.textContent = text;
        }
    }

    function showHostInfoPlaceholder(message, badgeText = 'Idle') {
        if (!hostInfoPlaceholder || !hostInfoSection) {
            return;
        }
        clearHostInfoTimer();
        resetHostInfoFields();
        hostInfoPlaceholder.textContent = message;
        hostInfoPlaceholder.style.display = '';
        hostInfoSection.style.display = 'none';
        if (hostInfoMessage) {
            hostInfoMessage.textContent = '';
            hostInfoMessage.className = 'notice';
            hostInfoMessage.style.display = 'none';
        }
        setHostInfoBadge(badgeText);
    }

    function setHostInfoLoading(agent) {
        if (!hostInfoPlaceholder || !hostInfoSection) {
            return;
        }
        clearHostInfoTimer();
        resetHostInfoFields();
        hostInfoPlaceholder.textContent = `Collecting host diagnostics from ${agent.name}…`;
        hostInfoPlaceholder.style.display = '';
        hostInfoSection.style.display = 'none';
        if (hostInfoMessage) {
            hostInfoMessage.textContent = '';
            hostInfoMessage.className = 'notice';
            hostInfoMessage.style.display = 'none';
        }
        setHostInfoBadge('Loading…');
    }

    function showHostInfoError(message) {
        if (!hostInfoSection || !hostInfoPlaceholder) {
            return;
        }
        clearHostInfoTimer();
        resetHostInfoFields();
        hostInfoSection.style.display = '';
        hostInfoPlaceholder.style.display = 'none';
        if (hostInfoMessage) {
            hostInfoMessage.textContent = message;
            hostInfoMessage.className = 'notice danger';
            hostInfoMessage.style.display = '';
        }
        setHostInfoBadge('Error');
        if (hostInfoUpdated) {
            hostInfoUpdated.textContent = '—';
        }
    }

    function renderHostInfo(payload) {
        if (!hostInfoSection || !hostInfoPlaceholder) {
            return;
        }
        resetHostInfoFields();
        hostInfoPlaceholder.style.display = 'none';
        hostInfoSection.style.display = '';

        if (hostInfoMessage) {
            if (Array.isArray(payload.warnings) && payload.warnings.length) {
                hostInfoMessage.textContent = payload.warnings.join(' ');
                hostInfoMessage.className = 'notice warning';
                hostInfoMessage.style.display = '';
            } else {
                hostInfoMessage.textContent = '';
                hostInfoMessage.className = 'notice';
                hostInfoMessage.style.display = 'none';
            }
        }

        const system = payload.system || {};
        if (hostSystemHostname) {
            hostSystemHostname.textContent = system.hostname || '—';
        }
        if (hostSystemUser) {
            hostSystemUser.textContent = system.username || '—';
        }
        if (hostKernel) {
            hostKernel.textContent = system.kernel || 'Unavailable';
        }

        const nodeinfo = payload.nodeinfo || {};
        if (hostCpuModel) {
            hostCpuModel.textContent = nodeinfo['CPU model'] || '—';
        }
        if (hostCpuCount) {
            hostCpuCount.textContent = nodeinfo['CPU(s)'] || '—';
        }
        if (hostCpuFrequency) {
            hostCpuFrequency.textContent = nodeinfo['CPU frequency'] || '—';
        }
        if (hostMemoryTotal) {
            hostMemoryTotal.textContent = formatNodeinfoMemory(nodeinfo['Memory size']);
        }

        const performance = payload.performance || {};
        if (hostLoad) {
            hostLoad.textContent = formatLoadAverage(performance.load_average);
        }
        const memory = performance.memory || null;
        if (hostMemoryUsage) {
            hostMemoryUsage.textContent = formatMemoryUsage(memory);
        }
        if (hostMemoryAvailable) {
            hostMemoryAvailable.textContent = memory && isFiniteNumber(memory.available_bytes)
                ? humanizeBytes(memory.available_bytes)
                : 'Unavailable';
        }

        if (hostInfoUpdated) {
            hostInfoUpdated.textContent = payload.collected_at
                ? new Date(payload.collected_at).toLocaleString()
                : '—';
        }
        if (hostInfoTimestamp) {
            hostInfoTimestamp.textContent = payload.collected_at
                ? `Updated ${new Date(payload.collected_at).toLocaleTimeString()}`
                : 'Updated just now';
        }
    }

    function scheduleHostInfoRefresh(agent) {
        clearHostInfoTimer();
        if (!agent || !state.endpoints.host_info) {
            return;
        }
        hostInfoTimer = window.setTimeout(() => {
            if (!state.selectedAgent || state.selectedAgent.id !== agent.id) {
                return;
            }
            fetchHostInfo(agent, { showLoading: false });
        }, 15000);
    }

    async function fetchHostInfo(agent, options = {}) {
        const { showLoading = true } = options;

        if (!hostInfoSection || !hostInfoPlaceholder) {
            return;
        }

        if (!agent) {
            const message = state.agents.length
                ? 'Select a hypervisor to view system metrics.'
                : 'Register a hypervisor to monitor its performance metrics.';
            showHostInfoPlaceholder(message, 'Idle');
            return;
        }

        if (!state.endpoints.host_info) {
            showHostInfoError('Host diagnostics endpoint is not available.');
            return;
        }

        if (showLoading) {
            setHostInfoLoading(agent);
        }

        try {
            clearHostInfoTimer();
            const url = buildUrl(state.endpoints.host_info, agent.id);
            const response = await fetch(url, { credentials: 'same-origin' });
            const payload = await response.json();
            if (payload.status !== 'ok') {
                throw new Error(payload.message || 'Unable to retrieve host diagnostics.');
            }
            if (!state.selectedAgent || state.selectedAgent.id !== agent.id) {
                return;
            }
            renderHostInfo(payload);
            scheduleHostInfoRefresh(agent);
        } catch (error) {
            showHostInfoError(error.message || 'Unable to retrieve host diagnostics.');
        }
    }

    function renderAgents() {
        if (!agentList) {
            return;
        }
        agentList.innerHTML = '';
        if (!state.agents.length) {
            const empty = document.createElement('p');
            empty.className = 'muted';
            empty.textContent = 'No hypervisors registered yet. Use the form to onboard your first agent.';
            agentList.appendChild(empty);
            return;
        }
        state.agents.forEach((agent) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'agent-entry';
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'agent-tile' + (state.selectedAgent && state.selectedAgent.id === agent.id ? ' active' : '');
            button.dataset.agentId = String(agent.id);
            button.innerHTML = `<strong>${agent.name}</strong>
                <div class="agent-meta">
                    <span>${agent.hostname}:${agent.port}</span>
                    <span>SSH · ${agent.username}</span>
                </div>`;
            button.addEventListener('click', () => {
                selectAgent(agent);
            });
            wrapper.appendChild(button);

            const actions = document.createElement('div');
            actions.className = 'agent-actions';
            const created = document.createElement('span');
            created.className = 'muted';
            try {
                created.textContent = `Created ${new Date(agent.created_at).toLocaleString()}`;
            } catch (_) {
                created.textContent = 'Created recently';
            }
            actions.appendChild(created);

            const form = document.createElement('form');
            form.method = 'post';
            form.action = agent.remove_url;
            form.innerHTML = '<button type="submit" class="text-button">Remove</button>';
            form.addEventListener('submit', (event) => {
                if (!confirm(`Remove ${agent.name}?`)) {
                    event.preventDefault();
                }
            });
            actions.appendChild(form);
            wrapper.appendChild(actions);

            agentList.appendChild(wrapper);
        });
    }

    function updateSshSection(agent) {
        if (!sshCommand || !sshSection || !sshPlaceholder) {
            return;
        }
        if (!agent) {
            sshSection.style.display = 'none';
            sshPlaceholder.style.display = '';
            sshCommand.textContent = '';
            disconnectTerminal(false);
            showTerminalOverlay('Select a hypervisor and click Connect to start a session.');
            setTerminalStatus('Disconnected.');
            if (sshConnectButton) {
                sshConnectButton.setAttribute('disabled', 'true');
            }
            if (sshDisconnectButton) {
                sshDisconnectButton.setAttribute('disabled', 'true');
            }
            if (sshCopyButton) {
                if (sshCopyButtonLabel) {
                    sshCopyButton.textContent = sshCopyButtonLabel;
                }
                sshCopyButton.setAttribute('disabled', 'true');
            }
            return;
        }

        const command = agent.port === 22
            ? `ssh ${agent.username}@${agent.hostname}`
            : `ssh -p ${agent.port} ${agent.username}@${agent.hostname}`;
        sshCommand.textContent = command;
        sshSection.style.display = '';
        sshPlaceholder.style.display = 'none';

        const connectedToAgent = Boolean(
            terminalSocket && terminalSocket.readyState === WebSocket.OPEN && terminalAgentId === agent.id,
        );

        if (terminalAgentId !== null && terminalAgentId !== agent.id) {
            disconnectTerminal(false);
        }

        if (connectedToAgent) {
            hideTerminalOverlay();
            setTerminalStatus(`Connected to ${agent.hostname}`);
            if (sshConnectButton) {
                sshConnectButton.setAttribute('disabled', 'true');
            }
            if (sshDisconnectButton) {
                sshDisconnectButton.removeAttribute('disabled');
            }
        } else {
            showTerminalOverlay(`Click Connect to open a session with ${agent.name}.`);
            setTerminalStatus('Ready to connect.');
            if (sshConnectButton) {
                sshConnectButton.removeAttribute('disabled');
            }
            if (sshDisconnectButton) {
                sshDisconnectButton.setAttribute('disabled', 'true');
            }
            clearTerminal();
            ensureTerminal();
            if (fitAddon) {
                requestAnimationFrame(() => {
                    fitAddon.fit();
                    sendTerminalResize();
                });
            }
        }

        if (sshCopyButton) {
            sshCopyButton.removeAttribute('disabled');
            if (sshCopyButtonLabel) {
                sshCopyButton.textContent = sshCopyButtonLabel;
            }
        }
    }

    function updateAgentLabel(agent) {
        if (agentLabel) {
            agentLabel.textContent = agent ? agent.name : 'No agent selected';
        }
    }

    function setVmStatus(message, isError = false) {
        if (!vmStatus) {
            return;
        }
        vmStatus.textContent = message;
        vmStatus.classList.toggle('danger', isError);
    }

    function renderVmTable(vms) {
        if (!vmTableBody || !vmTableWrapper) {
            return;
        }
        vmTableBody.innerHTML = '';
        if (!vms.length) {
            setVmStatus('No virtual machines reported by the selected hypervisor.');
            vmTableWrapper.style.display = 'none';
            return;
        }
        vmTableWrapper.style.display = '';
        vms.forEach((vm) => {
            const row = document.createElement('tr');
            const nameCell = document.createElement('td');
            nameCell.textContent = vm.name;
            row.appendChild(nameCell);

            const stateCell = document.createElement('td');
            const normalizedState = (vm.state || '').toLowerCase();
            const dot = document.createElement('span');
            let stateClass = 'status-other';
            if (normalizedState.includes('running')) {
                stateClass = 'status-running';
            } else if (normalizedState.includes('shut') || normalizedState.includes('off')) {
                stateClass = 'status-shutoff';
            } else if (normalizedState.includes('pause')) {
                stateClass = 'status-paused';
            }
            dot.className = 'status-dot ' + stateClass;
            const label = document.createElement('span');
            label.appendChild(dot);
            label.append(vm.state);
            stateCell.appendChild(label);
            row.appendChild(stateCell);

            const actionsCell = document.createElement('td');
            actionsCell.className = 'vm-actions';

            const makeActionButton = (label, action, variant) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'button small' + (variant ? ' ' + variant : '');
                button.textContent = label;
                button.addEventListener('click', () => triggerVmAction(vm.name, action));
                return button;
            };

            actionsCell.appendChild(makeActionButton('Start', 'start'));
            actionsCell.appendChild(makeActionButton('Shutdown', 'shutdown'));
            actionsCell.appendChild(makeActionButton('Force stop', 'force-stop', 'danger'));
            actionsCell.appendChild(makeActionButton('Reboot', 'reboot'));
            row.appendChild(actionsCell);

            vmTableBody.appendChild(row);
        });
    }

    async function fetchVms(agent) {
        if (!agent) {
            if (vmTableBody) {
                vmTableBody.innerHTML = '';
            }
            if (vmTableWrapper) {
                vmTableWrapper.style.display = 'none';
            }
            setVmStatus('Select a hypervisor to load its virtual machines.');
            return;
        }
        setVmStatus('Querying virtual machines from ' + agent.name + '…');
        try {
            const url = buildUrl(state.endpoints.list_vms, agent.id);
            const response = await fetch(url, { credentials: 'same-origin' });
            const payload = await response.json();
            if (payload.status !== 'ok') {
                throw new Error(payload.message || 'Unable to list virtual machines.');
            }
            renderVmTable(payload.vms || []);
            if ((payload.vms || []).length) {
                setVmStatus(`${payload.vms.length} virtual machine(s) reported by ${agent.name}.`);
            }
        } catch (error) {
            if (vmTableWrapper) {
                vmTableWrapper.style.display = 'none';
            }
            setVmStatus(error.message || 'Failed to query virtual machines.', true);
        }
    }

    async function triggerVmAction(vmName, action) {
        const agent = state.selectedAgent;
        if (!agent) {
            return;
        }
        setVmStatus(`Dispatching ${action} for ${vmName}…`);
        try {
            const url = buildUrl(state.endpoints.vm_action, agent.id, vmName, action);
            const response = await fetch(url, {
                method: 'POST',
                credentials: 'same-origin',
            });
            const payload = await response.json();
            if (payload.status !== 'ok') {
                throw new Error(payload.message || 'Operation failed.');
            }
            setVmStatus(payload.message || `Dispatched ${action} for ${vmName}.`);
            await fetchVms(agent);
        } catch (error) {
            setVmStatus(error.message || 'Operation failed.', true);
        }
    }

    function selectAgent(agent) {
        state.selectedAgent = agent;
        renderAgents();
        updateAgentLabel(agent);
        updateSshSection(agent);
        fetchVms(agent);
        fetchHostInfo(agent);
    }

    renderAgents();
    updateAgentLabel(state.selectedAgent);
    updateSshSection(state.selectedAgent);
    if (state.selectedAgent) {
        fetchVms(state.selectedAgent);
        fetchHostInfo(state.selectedAgent);
    } else if (state.agents.length) {
        setVmStatus('Select a hypervisor to load its virtual machines.');
        showHostInfoPlaceholder('Select a hypervisor to view system metrics.');
    } else {
        setVmStatus('Register a hypervisor to view its virtual machines.');
        showHostInfoPlaceholder('Register a hypervisor to monitor its performance metrics.');
    }
})();
</script>
{% endblock %}
